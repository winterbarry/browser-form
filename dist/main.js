/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/@form-validation/core/lib/cjs/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/@form-validation/core/lib/cjs/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implement Luhn validation algorithm\n * Credit to https://gist.github.com/ShirtlessKirk/2134376\n *\n * @see http://en.wikipedia.org/wiki/Luhn\n * @param {string} value\n * @returns {boolean}\n */\nfunction luhn(value) {\n    var length = value.length;\n    var prodArr = [\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [0, 2, 4, 6, 8, 1, 3, 5, 7, 9],\n    ];\n    var mul = 0;\n    var sum = 0;\n    while (length--) {\n        sum += prodArr[mul][parseInt(value.charAt(length), 10)];\n        mul = 1 - mul;\n    }\n    return sum % 10 === 0 && sum > 0;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implement modulus 11, 10 (ISO 7064) algorithm\n *\n * @param {string} value\n * @returns {boolean}\n */\nfunction mod11And10(value) {\n    var length = value.length;\n    var check = 5;\n    for (var i = 0; i < length; i++) {\n        check = ((((check || 10) * 2) % 11) + parseInt(value.charAt(i), 10)) % 10;\n    }\n    return check === 1;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implements Mod 37, 36 (ISO 7064) algorithm\n *\n * @param {string} value\n * @param {string} [alphabet]\n * @returns {boolean}\n */\nfunction mod37And36(value, alphabet) {\n    if (alphabet === void 0) { alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; }\n    var length = value.length;\n    var modulus = alphabet.length;\n    var check = Math.floor(modulus / 2);\n    for (var i = 0; i < length; i++) {\n        check = ((((check || modulus) * 2) % (modulus + 1)) + alphabet.indexOf(value.charAt(i))) % modulus;\n    }\n    return check === 1;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nfunction transform(input) {\n    return input\n        .split('')\n        .map(function (c) {\n        var code = c.charCodeAt(0);\n        // 65, 66, ..., 90 are the char code of A, B, ..., Z\n        return code >= 65 && code <= 90\n            ? // Replace A, B, C, ..., Z with 10, 11, ..., 35\n                code - 55\n            : c;\n    })\n        .join('')\n        .split('')\n        .map(function (c) { return parseInt(c, 10); });\n}\nfunction mod97And10(input) {\n    var digits = transform(input);\n    var temp = 0;\n    var length = digits.length;\n    for (var i = 0; i < length - 1; ++i) {\n        temp = ((temp + digits[i]) * 10) % 97;\n    }\n    temp += digits[length - 1];\n    return temp % 97 === 1;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Implement Verhoeff validation algorithm\n * Credit to Sergey Petushkov, 2014\n *\n * @see https://en.wikipedia.org/wiki/Verhoeff_algorithm\n * @param {string} value\n * @returns {boolean}\n */\nfunction verhoeff(value) {\n    // Multiplication table d\n    var d = [\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [1, 2, 3, 4, 0, 6, 7, 8, 9, 5],\n        [2, 3, 4, 0, 1, 7, 8, 9, 5, 6],\n        [3, 4, 0, 1, 2, 8, 9, 5, 6, 7],\n        [4, 0, 1, 2, 3, 9, 5, 6, 7, 8],\n        [5, 9, 8, 7, 6, 0, 4, 3, 2, 1],\n        [6, 5, 9, 8, 7, 1, 0, 4, 3, 2],\n        [7, 6, 5, 9, 8, 2, 1, 0, 4, 3],\n        [8, 7, 6, 5, 9, 3, 2, 1, 0, 4],\n        [9, 8, 7, 6, 5, 4, 3, 2, 1, 0],\n    ];\n    // Permutation table p\n    var p = [\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [1, 5, 7, 6, 2, 8, 3, 0, 9, 4],\n        [5, 8, 0, 3, 7, 9, 6, 1, 4, 2],\n        [8, 9, 1, 6, 0, 4, 3, 5, 2, 7],\n        [9, 4, 5, 3, 1, 2, 6, 8, 7, 0],\n        [4, 2, 8, 6, 5, 7, 3, 9, 0, 1],\n        [2, 7, 9, 3, 8, 0, 6, 4, 1, 5],\n        [7, 0, 4, 6, 9, 1, 3, 2, 5, 8],\n    ];\n    // Inverse table inv\n    var invertedArray = value.reverse();\n    var c = 0;\n    for (var i = 0; i < invertedArray.length; i++) {\n        c = d[c][p[i % 8][invertedArray[i]]];\n    }\n    return c === 0;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar index$1 = {\n    luhn: luhn,\n    mod11And10: mod11And10,\n    mod37And36: mod37And36,\n    mod97And10: mod97And10,\n    verhoeff: verhoeff,\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * @param {HTMLElement} form The form element\n * @param {string} field The field name\n * @param {HTMLElement} element The field element\n * @param {HTMLElement[]} elements The list of elements which have the same name as `field`\n * @return {string}\n */\nfunction getFieldValue(form, field, element, elements) {\n    var type = (element.getAttribute('type') || '').toLowerCase();\n    var tagName = element.tagName.toLowerCase();\n    if (tagName === 'textarea') {\n        return element.value;\n    }\n    if (tagName === 'select') {\n        var select = element;\n        var index = select.selectedIndex;\n        return index >= 0 ? select.options.item(index).value : '';\n    }\n    if (tagName === 'input') {\n        if ('radio' === type || 'checkbox' === type) {\n            var checked = elements.filter(function (ele) { return ele.checked; }).length;\n            return checked === 0 ? '' : checked + '';\n        }\n        else {\n            return element.value;\n        }\n    }\n    return '';\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nfunction emitter() {\n    return {\n        fns: {},\n        clear: function () {\n            this.fns = {};\n        },\n        emit: function (event) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            (this.fns[event] || []).map(function (handler) { return handler.apply(handler, args); });\n        },\n        off: function (event, func) {\n            if (this.fns[event]) {\n                var index = this.fns[event].indexOf(func);\n                if (index >= 0) {\n                    this.fns[event].splice(index, 1);\n                }\n            }\n        },\n        on: function (event, func) {\n            (this.fns[event] = this.fns[event] || []).push(func);\n        },\n    };\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nfunction filter() {\n    return {\n        filters: {},\n        add: function (name, func) {\n            (this.filters[name] = this.filters[name] || []).push(func);\n        },\n        clear: function () {\n            this.filters = {};\n        },\n        execute: function (name, defaultValue, args) {\n            if (!this.filters[name] || !this.filters[name].length) {\n                return defaultValue;\n            }\n            var result = defaultValue;\n            var filters = this.filters[name];\n            var count = filters.length;\n            for (var i = 0; i < count; i++) {\n                result = filters[i].apply(result, args);\n            }\n            return result;\n        },\n        remove: function (name, func) {\n            if (this.filters[name]) {\n                this.filters[name] = this.filters[name].filter(function (f) { return f !== func; });\n            }\n        },\n    };\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar Core = /** @class */ (function () {\n    function Core(form, fields) {\n        this.fields = {};\n        this.elements = {};\n        this.ee = emitter();\n        this.filter = filter();\n        this.plugins = {};\n        // Store the result of validation for each field\n        this.results = new Map();\n        this.validators = {};\n        this.form = form;\n        this.fields = fields;\n    }\n    Core.prototype.on = function (event, func) {\n        this.ee.on(event, func);\n        return this;\n    };\n    Core.prototype.off = function (event, func) {\n        this.ee.off(event, func);\n        return this;\n    };\n    Core.prototype.emit = function (event) {\n        var _a;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        (_a = this.ee).emit.apply(_a, __spreadArray([event], args, false));\n        return this;\n    };\n    Core.prototype.registerPlugin = function (name, plugin) {\n        // Check if whether the plugin is registered\n        if (this.plugins[name]) {\n            throw new Error(\"The plguin \".concat(name, \" is registered\"));\n        }\n        // Install the plugin\n        plugin.setCore(this);\n        plugin.install();\n        this.plugins[name] = plugin;\n        return this;\n    };\n    Core.prototype.deregisterPlugin = function (name) {\n        var plugin = this.plugins[name];\n        if (plugin) {\n            plugin.uninstall();\n        }\n        delete this.plugins[name];\n        return this;\n    };\n    Core.prototype.enablePlugin = function (name) {\n        var plugin = this.plugins[name];\n        if (plugin) {\n            plugin.enable();\n        }\n        return this;\n    };\n    Core.prototype.disablePlugin = function (name) {\n        var plugin = this.plugins[name];\n        if (plugin) {\n            plugin.disable();\n        }\n        return this;\n    };\n    Core.prototype.isPluginEnabled = function (name) {\n        var plugin = this.plugins[name];\n        return plugin ? plugin.isPluginEnabled() : false;\n    };\n    Core.prototype.registerValidator = function (name, func) {\n        if (this.validators[name]) {\n            throw new Error(\"The validator \".concat(name, \" is registered\"));\n        }\n        this.validators[name] = func;\n        return this;\n    };\n    /**\n     * Add a filter\n     *\n     * @param {string} name The name of filter\n     * @param {Function} func The filter function\n     * @return {Core}\n     */\n    Core.prototype.registerFilter = function (name, func) {\n        this.filter.add(name, func);\n        return this;\n    };\n    /**\n     * Remove a filter\n     *\n     * @param {string} name The name of filter\n     * @param {Function} func The filter function\n     * @return {Core}\n     */\n    Core.prototype.deregisterFilter = function (name, func) {\n        this.filter.remove(name, func);\n        return this;\n    };\n    /**\n     * Execute a filter\n     *\n     * @param {string} name The name of filter\n     * @param {T} defaultValue The default value returns by the filter\n     * @param {array} args The filter arguments\n     * @returns {T}\n     */\n    Core.prototype.executeFilter = function (name, defaultValue, args) {\n        return this.filter.execute(name, defaultValue, args);\n    };\n    /**\n     * Add a field\n     *\n     * @param {string} field The field name\n     * @param {FieldOptions} options The field options. The options will be merged with the original validator rules\n     * if the field is already defined\n     * @return {Core}\n     */\n    Core.prototype.addField = function (field, options) {\n        var opts = Object.assign({}, {\n            selector: '',\n            validators: {},\n        }, options);\n        // Merge the options\n        this.fields[field] = this.fields[field]\n            ? {\n                selector: opts.selector || this.fields[field].selector,\n                validators: Object.assign({}, this.fields[field].validators, opts.validators),\n            }\n            : opts;\n        this.elements[field] = this.queryElements(field);\n        this.emit('core.field.added', {\n            elements: this.elements[field],\n            field: field,\n            options: this.fields[field],\n        });\n        return this;\n    };\n    /**\n     * Remove given field by name\n     *\n     * @param {string} field The field name\n     * @return {Core}\n     */\n    Core.prototype.removeField = function (field) {\n        if (!this.fields[field]) {\n            throw new Error(\"The field \".concat(field, \" validators are not defined. Please ensure the field is added first\"));\n        }\n        var elements = this.elements[field];\n        var options = this.fields[field];\n        delete this.elements[field];\n        delete this.fields[field];\n        this.emit('core.field.removed', {\n            elements: elements,\n            field: field,\n            options: options,\n        });\n        return this;\n    };\n    /**\n     * Validate all fields\n     *\n     * @return {Promise<string>}\n     */\n    Core.prototype.validate = function () {\n        var _this = this;\n        this.emit('core.form.validating', {\n            formValidation: this,\n        });\n        return this.filter.execute('validate-pre', Promise.resolve(), []).then(function () {\n            return Promise.all(Object.keys(_this.fields).map(function (field) { return _this.validateField(field); })).then(function (results) {\n                // `results` is an array of `Valid`, `Invalid` and `NotValidated`\n                switch (true) {\n                    case results.indexOf('Invalid') !== -1:\n                        _this.emit('core.form.invalid', {\n                            formValidation: _this,\n                        });\n                        return Promise.resolve('Invalid');\n                    case results.indexOf('NotValidated') !== -1:\n                        _this.emit('core.form.notvalidated', {\n                            formValidation: _this,\n                        });\n                        return Promise.resolve('NotValidated');\n                    default:\n                        _this.emit('core.form.valid', {\n                            formValidation: _this,\n                        });\n                        return Promise.resolve('Valid');\n                }\n            });\n        });\n    };\n    /**\n     * Validate a particular field\n     *\n     * @param {string} field The field name\n     * @return {Promise<string>}\n     */\n    Core.prototype.validateField = function (field) {\n        var _this = this;\n        // Stop validation process if the field is already validated\n        var result = this.results.get(field);\n        if (result === 'Valid' || result === 'Invalid') {\n            return Promise.resolve(result);\n        }\n        this.emit('core.field.validating', field);\n        var elements = this.elements[field];\n        if (elements.length === 0) {\n            this.emit('core.field.valid', field);\n            return Promise.resolve('Valid');\n        }\n        var type = elements[0].getAttribute('type');\n        if ('radio' === type || 'checkbox' === type || elements.length === 1) {\n            return this.validateElement(field, elements[0]);\n        }\n        else {\n            return Promise.all(elements.map(function (ele) { return _this.validateElement(field, ele); })).then(function (results) {\n                // `results` is an array of `Valid`, `Invalid` and `NotValidated`\n                switch (true) {\n                    case results.indexOf('Invalid') !== -1:\n                        _this.emit('core.field.invalid', field);\n                        _this.results.set(field, 'Invalid');\n                        return Promise.resolve('Invalid');\n                    case results.indexOf('NotValidated') !== -1:\n                        _this.emit('core.field.notvalidated', field);\n                        _this.results.delete(field);\n                        return Promise.resolve('NotValidated');\n                    default:\n                        _this.emit('core.field.valid', field);\n                        _this.results.set(field, 'Valid');\n                        return Promise.resolve('Valid');\n                }\n            });\n        }\n    };\n    /**\n     * Validate particular element\n     *\n     * @param {string} field The field name\n     * @param {HTMLElement} ele The field element\n     * @return {Promise<string>}\n     */\n    Core.prototype.validateElement = function (field, ele) {\n        var _this = this;\n        // Reset validation result\n        this.results.delete(field);\n        var elements = this.elements[field];\n        var ignored = this.filter.execute('element-ignored', false, [field, ele, elements]);\n        if (ignored) {\n            this.emit('core.element.ignored', {\n                element: ele,\n                elements: elements,\n                field: field,\n            });\n            return Promise.resolve('Ignored');\n        }\n        var validatorList = this.fields[field].validators;\n        this.emit('core.element.validating', {\n            element: ele,\n            elements: elements,\n            field: field,\n        });\n        var promises = Object.keys(validatorList).map(function (v) {\n            return function () { return _this.executeValidator(field, ele, v, validatorList[v]); };\n        });\n        return this.waterfall(promises)\n            .then(function (results) {\n            // `results` is an array of `Valid` or `Invalid`\n            var isValid = results.indexOf('Invalid') === -1;\n            _this.emit('core.element.validated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                valid: isValid,\n            });\n            var type = ele.getAttribute('type');\n            if ('radio' === type || 'checkbox' === type || elements.length === 1) {\n                _this.emit(isValid ? 'core.field.valid' : 'core.field.invalid', field);\n            }\n            return Promise.resolve(isValid ? 'Valid' : 'Invalid');\n        })\n            .catch(function (reason) {\n            // reason is `NotValidated`\n            _this.emit('core.element.notvalidated', {\n                element: ele,\n                elements: elements,\n                field: field,\n            });\n            return Promise.resolve(reason);\n        });\n    };\n    /**\n     * Perform given validator on field\n     *\n     * @param {string} field The field name\n     * @param {HTMLElement} ele The field element\n     * @param {string} v The validator name\n     * @param {ValidatorOptions} opts The validator options\n     * @return {Promise<string>}\n     */\n    Core.prototype.executeValidator = function (field, ele, v, opts) {\n        var _this = this;\n        var elements = this.elements[field];\n        var name = this.filter.execute('validator-name', v, [v, field]);\n        opts.message = this.filter.execute('validator-message', opts.message, [this.locale, field, name]);\n        // Simply pass the validator if\n        // - it isn't defined yet\n        // - or the associated validator isn't enabled\n        if (!this.validators[name] || opts.enabled === false) {\n            this.emit('core.validator.validated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                result: this.normalizeResult(field, name, { valid: true }),\n                validator: name,\n            });\n            return Promise.resolve('Valid');\n        }\n        var validator = this.validators[name];\n        // Get the field value\n        var value = this.getElementValue(field, ele, name);\n        var willValidate = this.filter.execute('field-should-validate', true, [field, ele, value, v]);\n        if (!willValidate) {\n            this.emit('core.validator.notvalidated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                validator: v,\n            });\n            return Promise.resolve('NotValidated');\n        }\n        this.emit('core.validator.validating', {\n            element: ele,\n            elements: elements,\n            field: field,\n            validator: v,\n        });\n        // Perform validation\n        var result = validator().validate({\n            element: ele,\n            elements: elements,\n            field: field,\n            l10n: this.localization,\n            options: opts,\n            value: value,\n        });\n        // Check whether the result is a `Promise`\n        var isPromise = 'function' === typeof result['then'];\n        if (isPromise) {\n            return result.then(function (r) {\n                var data = _this.normalizeResult(field, v, r);\n                _this.emit('core.validator.validated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                    result: data,\n                    validator: v,\n                });\n                return data.valid ? 'Valid' : 'Invalid';\n            });\n        }\n        else {\n            var data = this.normalizeResult(field, v, result);\n            this.emit('core.validator.validated', {\n                element: ele,\n                elements: elements,\n                field: field,\n                result: data,\n                validator: v,\n            });\n            return Promise.resolve(data.valid ? 'Valid' : 'Invalid');\n        }\n    };\n    Core.prototype.getElementValue = function (field, ele, validator) {\n        var defaultValue = getFieldValue(this.form, field, ele, this.elements[field]);\n        return this.filter.execute('field-value', defaultValue, [defaultValue, field, ele, validator]);\n    };\n    // Some getter methods\n    Core.prototype.getElements = function (field) {\n        return this.elements[field];\n    };\n    Core.prototype.getFields = function () {\n        return this.fields;\n    };\n    Core.prototype.getFormElement = function () {\n        return this.form;\n    };\n    Core.prototype.getLocale = function () {\n        return this.locale;\n    };\n    Core.prototype.getPlugin = function (name) {\n        return this.plugins[name];\n    };\n    /**\n     * Update the field status\n     *\n     * @param {string} field The field name\n     * @param {string} status The new status\n     * @param {string} [validator] The validator name. If it isn't specified, all validators will be updated\n     * @return {Core}\n     */\n    Core.prototype.updateFieldStatus = function (field, status, validator) {\n        var _this = this;\n        var elements = this.elements[field];\n        var type = elements[0].getAttribute('type');\n        var list = 'radio' === type || 'checkbox' === type ? [elements[0]] : elements;\n        list.forEach(function (ele) { return _this.updateElementStatus(field, ele, status, validator); });\n        if (!validator) {\n            switch (status) {\n                case 'NotValidated':\n                    this.emit('core.field.notvalidated', field);\n                    this.results.delete(field);\n                    break;\n                case 'Validating':\n                    this.emit('core.field.validating', field);\n                    this.results.delete(field);\n                    break;\n                case 'Valid':\n                    this.emit('core.field.valid', field);\n                    this.results.set(field, 'Valid');\n                    break;\n                case 'Invalid':\n                    this.emit('core.field.invalid', field);\n                    this.results.set(field, 'Invalid');\n                    break;\n            }\n        }\n        else if (status === 'Invalid') {\n            // We need to mark the field as invalid because it doesn't pass the `validator`\n            this.emit('core.field.invalid', field);\n            this.results.set(field, 'Invalid');\n        }\n        return this;\n    };\n    /**\n     * Update the element status\n     *\n     * @param {string} field The field name\n     * @param {HTMLElement} ele The field element\n     * @param {string} status The new status\n     * @param {string} [validator] The validator name. If it isn't specified, all validators will be updated\n     * @return {Core}\n     */\n    Core.prototype.updateElementStatus = function (field, ele, status, validator) {\n        var _this = this;\n        var elements = this.elements[field];\n        var fieldValidators = this.fields[field].validators;\n        var validatorArr = validator ? [validator] : Object.keys(fieldValidators);\n        switch (status) {\n            case 'NotValidated':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.notvalidated', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.notvalidated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                });\n                break;\n            case 'Validating':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.validating', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.validating', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                });\n                break;\n            case 'Valid':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.validated', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        result: {\n                            message: fieldValidators[v].message,\n                            valid: true,\n                        },\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.validated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                    valid: true,\n                });\n                break;\n            case 'Invalid':\n                validatorArr.forEach(function (v) {\n                    return _this.emit('core.validator.validated', {\n                        element: ele,\n                        elements: elements,\n                        field: field,\n                        result: {\n                            message: fieldValidators[v].message,\n                            valid: false,\n                        },\n                        validator: v,\n                    });\n                });\n                this.emit('core.element.validated', {\n                    element: ele,\n                    elements: elements,\n                    field: field,\n                    valid: false,\n                });\n                break;\n        }\n        return this;\n    };\n    /**\n     * Reset the form. It also clears all the messages, hide the feedback icons, etc.\n     *\n     * @param {boolean} reset If true, the method resets field value to empty\n     * or remove `checked`, `selected` attributes\n     * @return {Core}\n     */\n    Core.prototype.resetForm = function (reset) {\n        var _this = this;\n        Object.keys(this.fields).forEach(function (field) { return _this.resetField(field, reset); });\n        this.emit('core.form.reset', {\n            formValidation: this,\n            reset: reset,\n        });\n        return this;\n    };\n    /**\n     * Reset the field. It also clears all the messages, hide the feedback icons, etc.\n     *\n     * @param {string} field The field name\n     * @param {boolean} reset If true, the method resets field value to empty\n     * or remove `checked`, `selected` attributes\n     * @return {Core}\n     */\n    Core.prototype.resetField = function (field, reset) {\n        // Reset the field element value if needed\n        if (reset) {\n            var elements = this.elements[field];\n            var type_1 = elements[0].getAttribute('type');\n            elements.forEach(function (ele) {\n                if ('radio' === type_1 || 'checkbox' === type_1) {\n                    ele.removeAttribute('selected');\n                    ele.removeAttribute('checked');\n                    ele.checked = false;\n                }\n                else {\n                    ele.setAttribute('value', '');\n                    if (ele instanceof HTMLInputElement || ele instanceof HTMLTextAreaElement) {\n                        ele.value = '';\n                    }\n                }\n            });\n        }\n        // Mark the field as not validated yet\n        this.updateFieldStatus(field, 'NotValidated');\n        this.emit('core.field.reset', {\n            field: field,\n            reset: reset,\n        });\n        return this;\n    };\n    /**\n     * Revalidate a particular field. It's useful when the field value is effected by third parties\n     * (for example, attach another UI library to the field).\n     * Since there isn't an automatic way for FormValidation to know when the field value is modified in those cases,\n     * we need to revalidate the field manually.\n     *\n     * @param {string} field The field name\n     * @return {Promise<string>}\n     */\n    Core.prototype.revalidateField = function (field) {\n        if (!this.fields[field]) {\n            return Promise.resolve('Ignored');\n        }\n        this.updateFieldStatus(field, 'NotValidated');\n        return this.validateField(field);\n    };\n    /**\n     * Disable particular validator for given field\n     *\n     * @param {string} field The field name\n     * @param {string} validator The validator name. If it isn't specified, all validators will be disabled\n     * @return {Core}\n     */\n    Core.prototype.disableValidator = function (field, validator) {\n        if (!this.fields[field]) {\n            return this;\n        }\n        var elements = this.elements[field];\n        this.toggleValidator(false, field, validator);\n        this.emit('core.validator.disabled', {\n            elements: elements,\n            field: field,\n            formValidation: this,\n            validator: validator,\n        });\n        return this;\n    };\n    /**\n     * Enable particular validator for given field\n     *\n     * @param {string} field The field name\n     * @param {string} validator The validator name. If it isn't specified, all validators will be enabled\n     * @return {Core}\n     */\n    Core.prototype.enableValidator = function (field, validator) {\n        if (!this.fields[field]) {\n            return this;\n        }\n        var elements = this.elements[field];\n        this.toggleValidator(true, field, validator);\n        this.emit('core.validator.enabled', {\n            elements: elements,\n            field: field,\n            formValidation: this,\n            validator: validator,\n        });\n        return this;\n    };\n    /**\n     * Update option of particular validator for given field\n     *\n     * @param {string} field The field name\n     * @param {string} validator The validator name\n     * @param {string} name The option's name\n     * @param {unknown} value The option's value\n     * @return {Core}\n     */\n    Core.prototype.updateValidatorOption = function (field, validator, name, value) {\n        if (this.fields[field] && this.fields[field].validators && this.fields[field].validators[validator]) {\n            this.fields[field].validators[validator][name] = value;\n        }\n        return this;\n    };\n    Core.prototype.setFieldOptions = function (field, options) {\n        this.fields[field] = options;\n        return this;\n    };\n    Core.prototype.destroy = function () {\n        var _this = this;\n        // Remove plugins and filters\n        Object.keys(this.plugins).forEach(function (id) { return _this.plugins[id].uninstall(); });\n        this.ee.clear();\n        this.filter.clear();\n        this.results.clear();\n        this.plugins = {};\n        return this;\n    };\n    Core.prototype.setLocale = function (locale, localization) {\n        this.locale = locale;\n        this.localization = localization;\n        return this;\n    };\n    Core.prototype.waterfall = function (promises) {\n        return promises.reduce(function (p, c) {\n            return p.then(function (res) {\n                return c().then(function (result) {\n                    res.push(result);\n                    return res;\n                });\n            });\n        }, Promise.resolve([]));\n    };\n    Core.prototype.queryElements = function (field) {\n        var selector = this.fields[field].selector\n            ? // Check if the selector is an ID selector which starts with `#`\n                '#' === this.fields[field].selector.charAt(0)\n                    ? \"[id=\\\"\".concat(this.fields[field].selector.substring(1), \"\\\"]\")\n                    : this.fields[field].selector\n            : \"[name=\\\"\".concat(field.replace(/\"/g, '\\\\\"'), \"\\\"]\");\n        return [].slice.call(this.form.querySelectorAll(selector));\n    };\n    Core.prototype.normalizeResult = function (field, validator, result) {\n        var opts = this.fields[field].validators[validator];\n        return Object.assign({}, result, {\n            message: result.message ||\n                (opts ? opts.message : '') ||\n                (this.localization && this.localization[validator] && this.localization[validator]['default']\n                    ? this.localization[validator]['default']\n                    : '') ||\n                \"The field \".concat(field, \" is not valid\"),\n        });\n    };\n    Core.prototype.toggleValidator = function (enabled, field, validator) {\n        var _this = this;\n        var validatorArr = this.fields[field].validators;\n        if (validator && validatorArr && validatorArr[validator]) {\n            this.fields[field].validators[validator].enabled = enabled;\n        }\n        else if (!validator) {\n            Object.keys(validatorArr).forEach(function (v) { return (_this.fields[field].validators[v].enabled = enabled); });\n        }\n        return this.updateFieldStatus(field, 'NotValidated', validator);\n    };\n    return Core;\n}());\nfunction formValidation(form, options) {\n    var opts = Object.assign({}, {\n        fields: {},\n        locale: 'en_US',\n        plugins: {},\n        init: function (_) { },\n    }, options);\n    var core = new Core(form, opts.fields);\n    core.setLocale(opts.locale, opts.localization);\n    // Register plugins\n    Object.keys(opts.plugins).forEach(function (name) { return core.registerPlugin(name, opts.plugins[name]); });\n    // It's the single point that users can do a particular task before adding fields\n    // Some initialization tasks must be done at that point\n    opts.init(core);\n    // and add fields\n    Object.keys(opts.fields).forEach(function (field) { return core.addField(field, opts.fields[field]); });\n    return core;\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar Plugin = /** @class */ (function () {\n    function Plugin(opts) {\n        this.opts = opts;\n        this.isEnabled = true;\n    }\n    Plugin.prototype.setCore = function (core) {\n        this.core = core;\n        return this;\n    };\n    Plugin.prototype.enable = function () {\n        this.isEnabled = true;\n        this.onEnabled();\n        return this;\n    };\n    Plugin.prototype.disable = function () {\n        this.isEnabled = false;\n        this.onDisabled();\n        return this;\n    };\n    Plugin.prototype.isPluginEnabled = function () {\n        return this.isEnabled;\n    };\n    Plugin.prototype.onEnabled = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Plugin.prototype.onDisabled = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Plugin.prototype.install = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Plugin.prototype.uninstall = function () { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    return Plugin;\n}());\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Execute a callback function\n *\n * @param {Function | string} functionName Can be\n * - name of global function\n * - name of namespace function (such as A.B.C)\n * - a function\n * @param {any[]} args The callback arguments\n * @return {any}\n */\nfunction call(functionName, args) {\n    if ('function' === typeof functionName) {\n        return functionName.apply(this, args);\n    }\n    else if ('string' === typeof functionName) {\n        // Node that it doesn't support node.js based environment because we are trying to access `window`\n        var name_1 = functionName;\n        if ('()' === name_1.substring(name_1.length - 2)) {\n            name_1 = name_1.substring(0, name_1.length - 2);\n        }\n        var ns = name_1.split('.');\n        var func = ns.pop();\n        var context_1 = window;\n        for (var _i = 0, ns_1 = ns; _i < ns_1.length; _i++) {\n            var t = ns_1[_i];\n            context_1 = context_1[t];\n        }\n        return typeof context_1[func] === 'undefined' ? null : context_1[func].apply(this, args);\n    }\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar addClass = function (element, classes) {\n    classes.split(' ').forEach(function (clazz) {\n        if (element.classList) {\n            element.classList.add(clazz);\n        }\n        else if (\" \".concat(element.className, \" \").indexOf(\" \".concat(clazz, \" \"))) {\n            element.className += \" \".concat(clazz);\n        }\n    });\n};\nvar removeClass = function (element, classes) {\n    classes.split(' ').forEach(function (clazz) {\n        element.classList\n            ? element.classList.remove(clazz)\n            : (element.className = element.className.replace(clazz, ''));\n    });\n};\nvar classSet = function (element, classes) {\n    var adding = [];\n    var removing = [];\n    Object.keys(classes).forEach(function (clazz) {\n        if (clazz) {\n            classes[clazz] ? adding.push(clazz) : removing.push(clazz);\n        }\n    });\n    // Always remove before adding class because there might be a class which belong to both sets.\n    // For example, the element will have class `a` after calling\n    //  ```\n    //  classSet(element, {\n    //      'a a1 a2': true,\n    //      'a b1 b2': false\n    //  })\n    //  ```\n    removing.forEach(function (clazz) { return removeClass(element, clazz); });\n    adding.forEach(function (clazz) { return addClass(element, clazz); });\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar matches = function (element, selector) {\n    var nativeMatches = element.matches ||\n        element.webkitMatchesSelector ||\n        element['mozMatchesSelector'] ||\n        element['msMatchesSelector'];\n    if (nativeMatches) {\n        return nativeMatches.call(element, selector);\n    }\n    // In case `matchesselector` isn't supported (such as IE10)\n    // See http://caniuse.com/matchesselector\n    var nodes = [].slice.call(element.parentElement.querySelectorAll(selector));\n    return nodes.indexOf(element) >= 0;\n};\nvar closest = function (element, selector) {\n    var ele = element;\n    while (ele) {\n        if (matches(ele, selector)) {\n            break;\n        }\n        ele = ele.parentElement;\n    }\n    return ele;\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar generateString = function (length) {\n    return Array(length)\n        .fill('')\n        .map(function (v) { return Math.random().toString(36).charAt(2); })\n        .join('');\n};\nvar fetch = function (url, options) {\n    var toQuery = function (obj) {\n        return Object.keys(obj)\n            .map(function (k) { return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(obj[k])); })\n            .join('&');\n    };\n    return new Promise(function (resolve, reject) {\n        var opts = Object.assign({}, {\n            crossDomain: false,\n            headers: {},\n            method: 'GET',\n            params: {},\n        }, options);\n        // Build the params for GET request\n        var params = Object.keys(opts.params)\n            .map(function (k) { return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(opts.params[k])); })\n            .join('&');\n        var hasQuery = url.indexOf('?') > -1;\n        var requestUrl = 'GET' === opts.method ? \"\".concat(url).concat(hasQuery ? '&' : '?').concat(params) : url;\n        if (opts.crossDomain) {\n            // User is making cross domain request\n            var script_1 = document.createElement('script');\n            // In some very fast systems, the different `Date.now()` invocations can return the same value\n            // which leads to the issue where there are multiple remove validators are used, for example.\n            // Appending it with a generated random string can fix the value\n            var callback_1 = \"___FormValidationFetch_\".concat(generateString(12), \"___\");\n            window[callback_1] = function (data) {\n                delete window[callback_1];\n                resolve(data);\n            };\n            script_1.src = \"\".concat(requestUrl).concat(hasQuery ? '&' : '?', \"callback=\").concat(callback_1);\n            script_1.async = true;\n            script_1.addEventListener('load', function () {\n                script_1.parentNode.removeChild(script_1);\n            });\n            script_1.addEventListener('error', function () { return reject; });\n            document.head.appendChild(script_1);\n        }\n        else {\n            var request_1 = new XMLHttpRequest();\n            request_1.open(opts.method, requestUrl);\n            // Set the headers\n            request_1.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n            if ('POST' === opts.method) {\n                request_1.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n            }\n            Object.keys(opts.headers).forEach(function (k) { return request_1.setRequestHeader(k, opts.headers[k]); });\n            request_1.addEventListener('load', function () {\n                // Cannot use arrow function here due to the `this` scope\n                resolve(JSON.parse(this.responseText));\n            });\n            request_1.addEventListener('error', function () { return reject; });\n            // GET request will ignore the passed data here\n            request_1.send(toQuery(opts.params));\n        }\n    });\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Format a string\n * It's used to format the error message\n * format('The field must between %s and %s', [10, 20]) = 'The field must between 10 and 20'\n *\n * @param {string} message\n * @param {string|string[]} parameters\n * @returns {string}\n */\nvar format = function (message, parameters) {\n    var params = Array.isArray(parameters) ? parameters : [parameters];\n    var output = message;\n    params.forEach(function (p) {\n        output = output.replace('%s', p);\n    });\n    return output;\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar hasClass = function (element, clazz) {\n    return element.classList\n        ? element.classList.contains(clazz)\n        : new RegExp(\"(^| )\".concat(clazz, \"( |$)\"), 'gi').test(element.className);\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n/**\n * Validate a date\n *\n * @param {string} year The full year in 4 digits\n * @param {string} month The month number\n * @param {string} day The day number\n * @param {boolean} [notInFuture] If true, the date must not be in the future\n * @returns {boolean}\n */\nvar isValidDate = function (year, month, day, notInFuture) {\n    if (isNaN(year) || isNaN(month) || isNaN(day)) {\n        return false;\n    }\n    if (year < 1000 || year > 9999 || month <= 0 || month > 12) {\n        return false;\n    }\n    var numDays = [\n        31,\n        // Update the number of days in Feb of leap year\n        year % 400 === 0 || (year % 100 !== 0 && year % 4 === 0) ? 29 : 28,\n        31,\n        30,\n        31,\n        30,\n        31,\n        31,\n        30,\n        31,\n        30,\n        31,\n    ];\n    // Check the day\n    if (day <= 0 || day > numDays[month - 1]) {\n        return false;\n    }\n    if (notInFuture === true) {\n        var currentDate = new Date();\n        var currentYear = currentDate.getFullYear();\n        var currentMonth = currentDate.getMonth();\n        var currentDay = currentDate.getDate();\n        return (year < currentYear ||\n            (year === currentYear && month - 1 < currentMonth) ||\n            (year === currentYear && month - 1 === currentMonth && day < currentDay));\n    }\n    return true;\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar removeUndefined = function (obj) {\n    return obj\n        ? Object.entries(obj).reduce(function (a, _a) {\n            var k = _a[0], v = _a[1];\n            return (v === undefined ? a : ((a[k] = v), a));\n        }, {})\n        : {};\n};\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar index = {\n    call: call,\n    classSet: classSet,\n    closest: closest,\n    fetch: fetch,\n    format: format,\n    hasClass: hasClass,\n    isValidDate: isValidDate,\n    removeUndefined: removeUndefined,\n};\n\nexports.Plugin = Plugin;\nexports.algorithms = index$1;\nexports.formValidation = formValidation;\nexports.utils = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vY29yZS9saWIvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9jb3JlL2xpYi9janMvaW5kZXguanM/NjI2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnQgTHVobiB2YWxpZGF0aW9uIGFsZ29yaXRobVxuICogQ3JlZGl0IHRvIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1NoaXJ0bGVzc0tpcmsvMjEzNDM3NlxuICpcbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MdWhuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBsdWhuKHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgcHJvZEFyciA9IFtcbiAgICAgICAgWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldLFxuICAgICAgICBbMCwgMiwgNCwgNiwgOCwgMSwgMywgNSwgNywgOV0sXG4gICAgXTtcbiAgICB2YXIgbXVsID0gMDtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IHByb2RBcnJbbXVsXVtwYXJzZUludCh2YWx1ZS5jaGFyQXQobGVuZ3RoKSwgMTApXTtcbiAgICAgICAgbXVsID0gMSAtIG11bDtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSAlIDEwID09PSAwICYmIHN1bSA+IDA7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnQgbW9kdWx1cyAxMSwgMTAgKElTTyA3MDY0KSBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtb2QxMUFuZDEwKHZhbHVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgY2hlY2sgPSA1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2sgPSAoKCgoY2hlY2sgfHwgMTApICogMikgJSAxMSkgKyBwYXJzZUludCh2YWx1ZS5jaGFyQXQoaSksIDEwKSkgJSAxMDtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrID09PSAxO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbi8qKlxuICogSW1wbGVtZW50cyBNb2QgMzcsIDM2IChJU08gNzA2NCkgYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FscGhhYmV0XVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG1vZDM3QW5kMzYodmFsdWUsIGFscGhhYmV0KSB7XG4gICAgaWYgKGFscGhhYmV0ID09PSB2b2lkIDApIHsgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJzsgfVxuICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgdmFyIG1vZHVsdXMgPSBhbHBoYWJldC5sZW5ndGg7XG4gICAgdmFyIGNoZWNrID0gTWF0aC5mbG9vcihtb2R1bHVzIC8gMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVjayA9ICgoKChjaGVjayB8fCBtb2R1bHVzKSAqIDIpICUgKG1vZHVsdXMgKyAxKSkgKyBhbHBoYWJldC5pbmRleE9mKHZhbHVlLmNoYXJBdChpKSkpICUgbW9kdWx1cztcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrID09PSAxO1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dFxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIC8vIDY1LCA2NiwgLi4uLCA5MCBhcmUgdGhlIGNoYXIgY29kZSBvZiBBLCBCLCAuLi4sIFpcbiAgICAgICAgcmV0dXJuIGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MFxuICAgICAgICAgICAgPyAvLyBSZXBsYWNlIEEsIEIsIEMsIC4uLiwgWiB3aXRoIDEwLCAxMSwgLi4uLCAzNVxuICAgICAgICAgICAgICAgIGNvZGUgLSA1NVxuICAgICAgICAgICAgOiBjO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKVxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHBhcnNlSW50KGMsIDEwKTsgfSk7XG59XG5mdW5jdGlvbiBtb2Q5N0FuZDEwKGlucHV0KSB7XG4gICAgdmFyIGRpZ2l0cyA9IHRyYW5zZm9ybShpbnB1dCk7XG4gICAgdmFyIHRlbXAgPSAwO1xuICAgIHZhciBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHRlbXAgPSAoKHRlbXAgKyBkaWdpdHNbaV0pICogMTApICUgOTc7XG4gICAgfVxuICAgIHRlbXAgKz0gZGlnaXRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiB0ZW1wICUgOTcgPT09IDE7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnQgVmVyaG9lZmYgdmFsaWRhdGlvbiBhbGdvcml0aG1cbiAqIENyZWRpdCB0byBTZXJnZXkgUGV0dXNoa292LCAyMDE0XG4gKlxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WZXJob2VmZl9hbGdvcml0aG1cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHZlcmhvZWZmKHZhbHVlKSB7XG4gICAgLy8gTXVsdGlwbGljYXRpb24gdGFibGUgZFxuICAgIHZhciBkID0gW1xuICAgICAgICBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0sXG4gICAgICAgIFsxLCAyLCAzLCA0LCAwLCA2LCA3LCA4LCA5LCA1XSxcbiAgICAgICAgWzIsIDMsIDQsIDAsIDEsIDcsIDgsIDksIDUsIDZdLFxuICAgICAgICBbMywgNCwgMCwgMSwgMiwgOCwgOSwgNSwgNiwgN10sXG4gICAgICAgIFs0LCAwLCAxLCAyLCAzLCA5LCA1LCA2LCA3LCA4XSxcbiAgICAgICAgWzUsIDksIDgsIDcsIDYsIDAsIDQsIDMsIDIsIDFdLFxuICAgICAgICBbNiwgNSwgOSwgOCwgNywgMSwgMCwgNCwgMywgMl0sXG4gICAgICAgIFs3LCA2LCA1LCA5LCA4LCAyLCAxLCAwLCA0LCAzXSxcbiAgICAgICAgWzgsIDcsIDYsIDUsIDksIDMsIDIsIDEsIDAsIDRdLFxuICAgICAgICBbOSwgOCwgNywgNiwgNSwgNCwgMywgMiwgMSwgMF0sXG4gICAgXTtcbiAgICAvLyBQZXJtdXRhdGlvbiB0YWJsZSBwXG4gICAgdmFyIHAgPSBbXG4gICAgICAgIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSxcbiAgICAgICAgWzEsIDUsIDcsIDYsIDIsIDgsIDMsIDAsIDksIDRdLFxuICAgICAgICBbNSwgOCwgMCwgMywgNywgOSwgNiwgMSwgNCwgMl0sXG4gICAgICAgIFs4LCA5LCAxLCA2LCAwLCA0LCAzLCA1LCAyLCA3XSxcbiAgICAgICAgWzksIDQsIDUsIDMsIDEsIDIsIDYsIDgsIDcsIDBdLFxuICAgICAgICBbNCwgMiwgOCwgNiwgNSwgNywgMywgOSwgMCwgMV0sXG4gICAgICAgIFsyLCA3LCA5LCAzLCA4LCAwLCA2LCA0LCAxLCA1XSxcbiAgICAgICAgWzcsIDAsIDQsIDYsIDksIDEsIDMsIDIsIDUsIDhdLFxuICAgIF07XG4gICAgLy8gSW52ZXJzZSB0YWJsZSBpbnZcbiAgICB2YXIgaW52ZXJ0ZWRBcnJheSA9IHZhbHVlLnJldmVyc2UoKTtcbiAgICB2YXIgYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnZlcnRlZEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGMgPSBkW2NdW3BbaSAlIDhdW2ludmVydGVkQXJyYXlbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIGMgPT09IDA7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGluZGV4JDEgPSB7XG4gICAgbHVobjogbHVobixcbiAgICBtb2QxMUFuZDEwOiBtb2QxMUFuZDEwLFxuICAgIG1vZDM3QW5kMzY6IG1vZDM3QW5kMzYsXG4gICAgbW9kOTdBbmQxMDogbW9kOTdBbmQxMCxcbiAgICB2ZXJob2VmZjogdmVyaG9lZmYsXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBmb3JtIFRoZSBmb3JtIGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZmllbGQgZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBlbGVtZW50cyBUaGUgbGlzdCBvZiBlbGVtZW50cyB3aGljaCBoYXZlIHRoZSBzYW1lIG5hbWUgYXMgYGZpZWxkYFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKGZvcm0sIGZpZWxkLCBlbGVtZW50LCBlbGVtZW50cykge1xuICAgIHZhciB0eXBlID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJykgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHZhciBzZWxlY3QgPSBlbGVtZW50O1xuICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3Quc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgPyBzZWxlY3Qub3B0aW9ucy5pdGVtKGluZGV4KS52YWx1ZSA6ICcnO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICBpZiAoJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlKSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tlZCA9IGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBlbGUuY2hlY2tlZDsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrZWQgPT09IDAgPyAnJyA6IGNoZWNrZWQgKyAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5mdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZuczoge30sXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZucyA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICBlbWl0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGhpcy5mbnNbZXZlbnRdIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGhhbmRsZXIuYXBwbHkoaGFuZGxlciwgYXJncyk7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgZnVuYykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm5zW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZm5zW2V2ZW50XS5pbmRleE9mKGZ1bmMpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm5zW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb246IGZ1bmN0aW9uIChldmVudCwgZnVuYykge1xuICAgICAgICAgICAgKHRoaXMuZm5zW2V2ZW50XSA9IHRoaXMuZm5zW2V2ZW50XSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbmZ1bmN0aW9uIGZpbHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWx0ZXJzOiB7fSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgICAgICAgICAgKHRoaXMuZmlsdGVyc1tuYW1lXSA9IHRoaXMuZmlsdGVyc1tuYW1lXSB8fCBbXSkucHVzaChmdW5jKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycyA9IHt9O1xuICAgICAgICB9LFxuICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyc1tuYW1lXSB8fCAhdGhpcy5maWx0ZXJzW25hbWVdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICB2YXIgY291bnQgPSBmaWx0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpbHRlcnNbaV0uYXBwbHkocmVzdWx0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcnNbbmFtZV0gPSB0aGlzLmZpbHRlcnNbbmFtZV0uZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmICE9PSBmdW5jOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbnZhciBDb3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvcmUoZm9ybSwgZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0ge307XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5lZSA9IGVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXIoKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgICAgIC8vIFN0b3JlIHRoZSByZXN1bHQgb2YgdmFsaWRhdGlvbiBmb3IgZWFjaCBmaWVsZFxuICAgICAgICB0aGlzLnJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudmFsaWRhdG9ycyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICB9XG4gICAgQ29yZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5lZS5vbihldmVudCwgZnVuYyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmdW5jKSB7XG4gICAgICAgIHRoaXMuZWUub2ZmKGV2ZW50LCBmdW5jKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5lZSkuZW1pdC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbZXZlbnRdLCBhcmdzLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUsIHBsdWdpbikge1xuICAgICAgICAvLyBDaGVjayBpZiB3aGV0aGVyIHRoZSBwbHVnaW4gaXMgcmVnaXN0ZXJlZFxuICAgICAgICBpZiAodGhpcy5wbHVnaW5zW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGxndWluIFwiLmNvbmNhdChuYW1lLCBcIiBpcyByZWdpc3RlcmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnN0YWxsIHRoZSBwbHVnaW5cbiAgICAgICAgcGx1Z2luLnNldENvcmUodGhpcyk7XG4gICAgICAgIHBsdWdpbi5pbnN0YWxsKCk7XG4gICAgICAgIHRoaXMucGx1Z2luc1tuYW1lXSA9IHBsdWdpbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5kZXJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMucGx1Z2luc1tuYW1lXTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgcGx1Z2luLnVuaW5zdGFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBsdWdpbnNbbmFtZV07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZW5hYmxlUGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBsdWdpbiA9IHRoaXMucGx1Z2luc1tuYW1lXTtcbiAgICAgICAgaWYgKHBsdWdpbikge1xuICAgICAgICAgICAgcGx1Z2luLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZGlzYWJsZVBsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbbmFtZV07XG4gICAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgICAgIHBsdWdpbi5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5pc1BsdWdpbkVuYWJsZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW5zW25hbWVdO1xuICAgICAgICByZXR1cm4gcGx1Z2luID8gcGx1Z2luLmlzUGx1Z2luRW5hYmxlZCgpIDogZmFsc2U7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5yZWdpc3RlclZhbGlkYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkYXRvcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB2YWxpZGF0b3IgXCIuY29uY2F0KG5hbWUsIFwiIGlzIHJlZ2lzdGVyZWRcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdG9yc1tuYW1lXSA9IGZ1bmM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiBmaWx0ZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmaWx0ZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtDb3JlfVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLnJlZ2lzdGVyRmlsdGVyID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIuYWRkKG5hbWUsIGZ1bmMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGZpbHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgZmlsdGVyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZmlsdGVyIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5kZXJlZ2lzdGVyRmlsdGVyID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIucmVtb3ZlKG5hbWUsIGZ1bmMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIGZpbHRlclxuICAgICAqIEBwYXJhbSB7VH0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybnMgYnkgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyZ3MgVGhlIGZpbHRlciBhcmd1bWVudHNcbiAgICAgKiBAcmV0dXJucyB7VH1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5leGVjdXRlRmlsdGVyID0gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIuZXhlY3V0ZShuYW1lLCBkZWZhdWx0VmFsdWUsIGFyZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7RmllbGRPcHRpb25zfSBvcHRpb25zIFRoZSBmaWVsZCBvcHRpb25zLiBUaGUgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBvcmlnaW5hbCB2YWxpZGF0b3IgcnVsZXNcbiAgICAgKiBpZiB0aGUgZmllbGQgaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5hZGRGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnJyxcbiAgICAgICAgICAgIHZhbGlkYXRvcnM6IHt9LFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgLy8gTWVyZ2UgdGhlIG9wdGlvbnNcbiAgICAgICAgdGhpcy5maWVsZHNbZmllbGRdID0gdGhpcy5maWVsZHNbZmllbGRdXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rvcjogb3B0cy5zZWxlY3RvciB8fCB0aGlzLmZpZWxkc1tmaWVsZF0uc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnMsIG9wdHMudmFsaWRhdG9ycyksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IG9wdHM7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbZmllbGRdID0gdGhpcy5xdWVyeUVsZW1lbnRzKGZpZWxkKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLmFkZGVkJywge1xuICAgICAgICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHNbZmllbGRdLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5maWVsZHNbZmllbGRdLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZ2l2ZW4gZmllbGQgYnkgbmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZW1vdmVGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzW2ZpZWxkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpZWxkIFwiLmNvbmNhdChmaWVsZCwgXCIgdmFsaWRhdG9ycyBhcmUgbm90IGRlZmluZWQuIFBsZWFzZSBlbnN1cmUgdGhlIGZpZWxkIGlzIGFkZGVkIGZpcnN0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmZpZWxkc1tmaWVsZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnJlbW92ZWQnLCB7XG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBhbGwgZmllbGRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdCgnY29yZS5mb3JtLnZhbGlkYXRpbmcnLCB7XG4gICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogdGhpcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5leGVjdXRlKCd2YWxpZGF0ZS1wcmUnLCBQcm9taXNlLnJlc29sdmUoKSwgW10pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF90aGlzLmZpZWxkcykubWFwKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gX3RoaXMudmFsaWRhdGVGaWVsZChmaWVsZCk7IH0pKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gYHJlc3VsdHNgIGlzIGFuIGFycmF5IG9mIGBWYWxpZGAsIGBJbnZhbGlkYCBhbmQgYE5vdFZhbGlkYXRlZGBcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSByZXN1bHRzLmluZGV4T2YoJ0ludmFsaWQnKSAhPT0gLTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLmZvcm0uaW52YWxpZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ0ludmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSByZXN1bHRzLmluZGV4T2YoJ05vdFZhbGlkYXRlZCcpICE9PSAtMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZm9ybS5ub3R2YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVZhbGlkYXRpb246IF90aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdOb3RWYWxpZGF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZm9ybS52YWxpZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtVmFsaWRhdGlvbjogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ1ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSBwYXJ0aWN1bGFyIGZpZWxkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudmFsaWRhdGVGaWVsZCA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTdG9wIHZhbGlkYXRpb24gcHJvY2VzcyBpZiB0aGUgZmllbGQgaXMgYWxyZWFkeSB2YWxpZGF0ZWRcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0cy5nZXQoZmllbGQpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSAnVmFsaWQnIHx8IHJlc3VsdCA9PT0gJ0ludmFsaWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnZhbGlkYXRpbmcnLCBmaWVsZCk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQudmFsaWQnLCBmaWVsZCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdWYWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gZWxlbWVudHNbMF0uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgfHwgZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUVsZW1lbnQoZmllbGQsIGVsZW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsZSkgeyByZXR1cm4gX3RoaXMudmFsaWRhdGVFbGVtZW50KGZpZWxkLCBlbGUpOyB9KSkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIC8vIGByZXN1bHRzYCBpcyBhbiBhcnJheSBvZiBgVmFsaWRgLCBgSW52YWxpZGAgYW5kIGBOb3RWYWxpZGF0ZWRgXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcmVzdWx0cy5pbmRleE9mKCdJbnZhbGlkJykgIT09IC0xOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdWx0cy5zZXQoZmllbGQsICdJbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdJbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgcmVzdWx0cy5pbmRleE9mKCdOb3RWYWxpZGF0ZWQnKSAhPT0gLTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLmZpZWxkLm5vdHZhbGlkYXRlZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdHMuZGVsZXRlKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ05vdFZhbGlkYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY29yZS5maWVsZC52YWxpZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdHMuc2V0KGZpZWxkLCAnVmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ1ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHBhcnRpY3VsYXIgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIFRoZSBmaWVsZCBuYW1lXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlIFRoZSBmaWVsZCBlbGVtZW50XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+fVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLnZhbGlkYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFJlc2V0IHZhbGlkYXRpb24gcmVzdWx0XG4gICAgICAgIHRoaXMucmVzdWx0cy5kZWxldGUoZmllbGQpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIGlnbm9yZWQgPSB0aGlzLmZpbHRlci5leGVjdXRlKCdlbGVtZW50LWlnbm9yZWQnLCBmYWxzZSwgW2ZpZWxkLCBlbGUsIGVsZW1lbnRzXSk7XG4gICAgICAgIGlmIChpZ25vcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC5pZ25vcmVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdJZ25vcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbGlkYXRvckxpc3QgPSB0aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9ycztcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IE9iamVjdC5rZXlzKHZhbGlkYXRvckxpc3QpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmV4ZWN1dGVWYWxpZGF0b3IoZmllbGQsIGVsZSwgdiwgdmFsaWRhdG9yTGlzdFt2XSk7IH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy53YXRlcmZhbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gYHJlc3VsdHNgIGlzIGFuIGFycmF5IG9mIGBWYWxpZGAgb3IgYEludmFsaWRgXG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IHJlc3VsdHMuaW5kZXhPZignSW52YWxpZCcpID09PSAtMTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgdmFsaWQ6IGlzVmFsaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZWxlLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgaWYgKCdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSB8fCBlbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KGlzVmFsaWQgPyAnY29yZS5maWVsZC52YWxpZCcgOiAnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpc1ZhbGlkID8gJ1ZhbGlkJyA6ICdJbnZhbGlkJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgLy8gcmVhc29uIGlzIGBOb3RWYWxpZGF0ZWRgXG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQubm90dmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBnaXZlbiB2YWxpZGF0b3Igb24gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZSBUaGUgZmllbGQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2IFRoZSB2YWxpZGF0b3IgbmFtZVxuICAgICAqIEBwYXJhbSB7VmFsaWRhdG9yT3B0aW9uc30gb3B0cyBUaGUgdmFsaWRhdG9yIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUuZXhlY3V0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlLCB2LCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuZmlsdGVyLmV4ZWN1dGUoJ3ZhbGlkYXRvci1uYW1lJywgdiwgW3YsIGZpZWxkXSk7XG4gICAgICAgIG9wdHMubWVzc2FnZSA9IHRoaXMuZmlsdGVyLmV4ZWN1dGUoJ3ZhbGlkYXRvci1tZXNzYWdlJywgb3B0cy5tZXNzYWdlLCBbdGhpcy5sb2NhbGUsIGZpZWxkLCBuYW1lXSk7XG4gICAgICAgIC8vIFNpbXBseSBwYXNzIHRoZSB2YWxpZGF0b3IgaWZcbiAgICAgICAgLy8gLSBpdCBpc24ndCBkZWZpbmVkIHlldFxuICAgICAgICAvLyAtIG9yIHRoZSBhc3NvY2lhdGVkIHZhbGlkYXRvciBpc24ndCBlbmFibGVkXG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0b3JzW25hbWVdIHx8IG9wdHMuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogdGhpcy5ub3JtYWxpemVSZXN1bHQoZmllbGQsIG5hbWUsIHsgdmFsaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdWYWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSB0aGlzLnZhbGlkYXRvcnNbbmFtZV07XG4gICAgICAgIC8vIEdldCB0aGUgZmllbGQgdmFsdWVcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRFbGVtZW50VmFsdWUoZmllbGQsIGVsZSwgbmFtZSk7XG4gICAgICAgIHZhciB3aWxsVmFsaWRhdGUgPSB0aGlzLmZpbHRlci5leGVjdXRlKCdmaWVsZC1zaG91bGQtdmFsaWRhdGUnLCB0cnVlLCBbZmllbGQsIGVsZSwgdmFsdWUsIHZdKTtcbiAgICAgICAgaWYgKCF3aWxsVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnTm90VmFsaWRhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci52YWxpZGF0aW5nJywge1xuICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICAgIHZhciByZXN1bHQgPSB2YWxpZGF0b3IoKS52YWxpZGF0ZSh7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGUsXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICBsMTBuOiB0aGlzLmxvY2FsaXphdGlvbixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdHMsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSByZXN1bHQgaXMgYSBgUHJvbWlzZWBcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9ICdmdW5jdGlvbicgPT09IHR5cGVvZiByZXN1bHRbJ3RoZW4nXTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfdGhpcy5ub3JtYWxpemVSZXN1bHQoZmllbGQsIHYsIHIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHYsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudmFsaWQgPyAnVmFsaWQnIDogJ0ludmFsaWQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMubm9ybWFsaXplUmVzdWx0KGZpZWxkLCB2LCByZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci52YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhLnZhbGlkID8gJ1ZhbGlkJyA6ICdJbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLmdldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGdldEZpZWxkVmFsdWUodGhpcy5mb3JtLCBmaWVsZCwgZWxlLCB0aGlzLmVsZW1lbnRzW2ZpZWxkXSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5leGVjdXRlKCdmaWVsZC12YWx1ZScsIGRlZmF1bHRWYWx1ZSwgW2RlZmF1bHRWYWx1ZSwgZmllbGQsIGVsZSwgdmFsaWRhdG9yXSk7XG4gICAgfTtcbiAgICAvLyBTb21lIGdldHRlciBtZXRob2RzXG4gICAgQ29yZS5wcm90b3R5cGUuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZ2V0RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5nZXRGb3JtRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybTtcbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLmdldExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZ2V0UGx1Z2luID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGx1Z2luc1tuYW1lXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZmllbGQgc3RhdHVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzIFRoZSBuZXcgc3RhdHVzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWxpZGF0b3JdIFRoZSB2YWxpZGF0b3IgbmFtZS4gSWYgaXQgaXNuJ3Qgc3BlY2lmaWVkLCBhbGwgdmFsaWRhdG9ycyB3aWxsIGJlIHVwZGF0ZWRcbiAgICAgKiBAcmV0dXJuIHtDb3JlfVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLnVwZGF0ZUZpZWxkU3RhdHVzID0gZnVuY3Rpb24gKGZpZWxkLCBzdGF0dXMsIHZhbGlkYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgdmFyIGxpc3QgPSAncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgPyBbZWxlbWVudHNbMF1dIDogZWxlbWVudHM7XG4gICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBfdGhpcy51cGRhdGVFbGVtZW50U3RhdHVzKGZpZWxkLCBlbGUsIHN0YXR1cywgdmFsaWRhdG9yKTsgfSk7XG4gICAgICAgIGlmICghdmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ05vdFZhbGlkYXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC5ub3R2YWxpZGF0ZWQnLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5kZWxldGUoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdWYWxpZGF0aW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnZhbGlkYXRpbmcnLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0cy5kZWxldGUoZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdWYWxpZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC52YWxpZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ1ZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ludmFsaWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZmllbGQuaW52YWxpZCcsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ0ludmFsaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzID09PSAnSW52YWxpZCcpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFyayB0aGUgZmllbGQgYXMgaW52YWxpZCBiZWNhdXNlIGl0IGRvZXNuJ3QgcGFzcyB0aGUgYHZhbGlkYXRvcmBcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5maWVsZC5pbnZhbGlkJywgZmllbGQpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChmaWVsZCwgJ0ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZWxlbWVudCBzdGF0dXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZSBUaGUgZmllbGQgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXMgVGhlIG5ldyBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbGlkYXRvcl0gVGhlIHZhbGlkYXRvciBuYW1lLiBJZiBpdCBpc24ndCBzcGVjaWZpZWQsIGFsbCB2YWxpZGF0b3JzIHdpbGwgYmUgdXBkYXRlZFxuICAgICAqIEByZXR1cm4ge0NvcmV9XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudXBkYXRlRWxlbWVudFN0YXR1cyA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlLCBzdGF0dXMsIHZhbGlkYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgdmFyIGZpZWxkVmFsaWRhdG9ycyA9IHRoaXMuZmllbGRzW2ZpZWxkXS52YWxpZGF0b3JzO1xuICAgICAgICB2YXIgdmFsaWRhdG9yQXJyID0gdmFsaWRhdG9yID8gW3ZhbGlkYXRvcl0gOiBPYmplY3Qua2V5cyhmaWVsZFZhbGlkYXRvcnMpO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSAnTm90VmFsaWRhdGVkJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3Iubm90dmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC5ub3R2YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWYWxpZGF0aW5nJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcjogdixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1ZhbGlkJzpcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JBcnIuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY29yZS52YWxpZGF0b3IudmFsaWRhdGVkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZmllbGRWYWxpZGF0b3JzW3ZdLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiB2LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSW52YWxpZCc6XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yQXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGZpZWxkVmFsaWRhdG9yc1t2XS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3I6IHYsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29yZS5lbGVtZW50LnZhbGlkYXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGZvcm0uIEl0IGFsc28gY2xlYXJzIGFsbCB0aGUgbWVzc2FnZXMsIGhpZGUgdGhlIGZlZWRiYWNrIGljb25zLCBldGMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0IElmIHRydWUsIHRoZSBtZXRob2QgcmVzZXRzIGZpZWxkIHZhbHVlIHRvIGVtcHR5XG4gICAgICogb3IgcmVtb3ZlIGBjaGVja2VkYCwgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZXNldEZvcm0gPSBmdW5jdGlvbiAocmVzZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5maWVsZHMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy5yZXNldEZpZWxkKGZpZWxkLCByZXNldCk7IH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ2NvcmUuZm9ybS5yZXNldCcsIHtcbiAgICAgICAgICAgIGZvcm1WYWxpZGF0aW9uOiB0aGlzLFxuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgZmllbGQuIEl0IGFsc28gY2xlYXJzIGFsbCB0aGUgbWVzc2FnZXMsIGhpZGUgdGhlIGZlZWRiYWNrIGljb25zLCBldGMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0IElmIHRydWUsIHRoZSBtZXRob2QgcmVzZXRzIGZpZWxkIHZhbHVlIHRvIGVtcHR5XG4gICAgICogb3IgcmVtb3ZlIGBjaGVja2VkYCwgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgICogQHJldHVybiB7Q29yZX1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZXNldEZpZWxkID0gZnVuY3Rpb24gKGZpZWxkLCByZXNldCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgZmllbGQgZWxlbWVudCB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzW2ZpZWxkXTtcbiAgICAgICAgICAgIHZhciB0eXBlXzEgPSBlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlXzEgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZV8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlbGUgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGUudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhlIGZpZWxkIGFzIG5vdCB2YWxpZGF0ZWQgeWV0XG4gICAgICAgIHRoaXMudXBkYXRlRmllbGRTdGF0dXMoZmllbGQsICdOb3RWYWxpZGF0ZWQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLmZpZWxkLnJlc2V0Jywge1xuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXZhbGlkYXRlIGEgcGFydGljdWxhciBmaWVsZC4gSXQncyB1c2VmdWwgd2hlbiB0aGUgZmllbGQgdmFsdWUgaXMgZWZmZWN0ZWQgYnkgdGhpcmQgcGFydGllc1xuICAgICAqIChmb3IgZXhhbXBsZSwgYXR0YWNoIGFub3RoZXIgVUkgbGlicmFyeSB0byB0aGUgZmllbGQpLlxuICAgICAqIFNpbmNlIHRoZXJlIGlzbid0IGFuIGF1dG9tYXRpYyB3YXkgZm9yIEZvcm1WYWxpZGF0aW9uIHRvIGtub3cgd2hlbiB0aGUgZmllbGQgdmFsdWUgaXMgbW9kaWZpZWQgaW4gdGhvc2UgY2FzZXMsXG4gICAgICogd2UgbmVlZCB0byByZXZhbGlkYXRlIHRoZSBmaWVsZCBtYW51YWxseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBDb3JlLnByb3RvdHlwZS5yZXZhbGlkYXRlRmllbGQgPSBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkc1tmaWVsZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ0lnbm9yZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUZpZWxkU3RhdHVzKGZpZWxkLCAnTm90VmFsaWRhdGVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBwYXJ0aWN1bGFyIHZhbGlkYXRvciBmb3IgZ2l2ZW4gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciBuYW1lLiBJZiBpdCBpc24ndCBzcGVjaWZpZWQsIGFsbCB2YWxpZGF0b3JzIHdpbGwgYmUgZGlzYWJsZWRcbiAgICAgKiBAcmV0dXJuIHtDb3JlfVxuICAgICAqL1xuICAgIENvcmUucHJvdG90eXBlLmRpc2FibGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZmllbGQsIHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzW2ZpZWxkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c1tmaWVsZF07XG4gICAgICAgIHRoaXMudG9nZ2xlVmFsaWRhdG9yKGZhbHNlLCBmaWVsZCwgdmFsaWRhdG9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci5kaXNhYmxlZCcsIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgIGZvcm1WYWxpZGF0aW9uOiB0aGlzLFxuICAgICAgICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3IsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBwYXJ0aWN1bGFyIHZhbGlkYXRvciBmb3IgZ2l2ZW4gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciBuYW1lLiBJZiBpdCBpc24ndCBzcGVjaWZpZWQsIGFsbCB2YWxpZGF0b3JzIHdpbGwgYmUgZW5hYmxlZFxuICAgICAqIEByZXR1cm4ge0NvcmV9XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUuZW5hYmxlVmFsaWRhdG9yID0gZnVuY3Rpb24gKGZpZWxkLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkc1tmaWVsZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNbZmllbGRdO1xuICAgICAgICB0aGlzLnRvZ2dsZVZhbGlkYXRvcih0cnVlLCBmaWVsZCwgdmFsaWRhdG9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb3JlLnZhbGlkYXRvci5lbmFibGVkJywge1xuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgZm9ybVZhbGlkYXRpb246IHRoaXMsXG4gICAgICAgICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvcixcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG9wdGlvbiBvZiBwYXJ0aWN1bGFyIHZhbGlkYXRvciBmb3IgZ2l2ZW4gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG9wdGlvbidzIG5hbWVcbiAgICAgKiBAcGFyYW0ge3Vua25vd259IHZhbHVlIFRoZSBvcHRpb24ncyB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0NvcmV9XG4gICAgICovXG4gICAgQ29yZS5wcm90b3R5cGUudXBkYXRlVmFsaWRhdG9yT3B0aW9uID0gZnVuY3Rpb24gKGZpZWxkLCB2YWxpZGF0b3IsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZpZWxkc1tmaWVsZF0gJiYgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnMgJiYgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnNbdmFsaWRhdG9yXSkge1xuICAgICAgICAgICAgdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnNbdmFsaWRhdG9yXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuc2V0RmllbGRPcHRpb25zID0gZnVuY3Rpb24gKGZpZWxkLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZmllbGRzW2ZpZWxkXSA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gUmVtb3ZlIHBsdWdpbnMgYW5kIGZpbHRlcnNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5wbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMucGx1Z2luc1tpZF0udW5pbnN0YWxsKCk7IH0pO1xuICAgICAgICB0aGlzLmVlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVzdWx0cy5jbGVhcigpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS5zZXRMb2NhbGUgPSBmdW5jdGlvbiAobG9jYWxlLCBsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbG9jYWxpemF0aW9uO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENvcmUucHJvdG90eXBlLndhdGVyZmFsbCA9IGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICByZXR1cm4gcHJvbWlzZXMucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYygpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIFByb21pc2UucmVzb2x2ZShbXSkpO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUucXVlcnlFbGVtZW50cyA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLmZpZWxkc1tmaWVsZF0uc2VsZWN0b3JcbiAgICAgICAgICAgID8gLy8gQ2hlY2sgaWYgdGhlIHNlbGVjdG9yIGlzIGFuIElEIHNlbGVjdG9yIHdoaWNoIHN0YXJ0cyB3aXRoIGAjYFxuICAgICAgICAgICAgICAgICcjJyA9PT0gdGhpcy5maWVsZHNbZmllbGRdLnNlbGVjdG9yLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICA/IFwiW2lkPVxcXCJcIi5jb25jYXQodGhpcy5maWVsZHNbZmllbGRdLnNlbGVjdG9yLnN1YnN0cmluZygxKSwgXCJcXFwiXVwiKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuZmllbGRzW2ZpZWxkXS5zZWxlY3RvclxuICAgICAgICAgICAgOiBcIltuYW1lPVxcXCJcIi5jb25jYXQoZmllbGQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLCBcIlxcXCJdXCIpO1xuICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLmZvcm0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIH07XG4gICAgQ29yZS5wcm90b3R5cGUubm9ybWFsaXplUmVzdWx0ID0gZnVuY3Rpb24gKGZpZWxkLCB2YWxpZGF0b3IsIHJlc3VsdCkge1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMuZmllbGRzW2ZpZWxkXS52YWxpZGF0b3JzW3ZhbGlkYXRvcl07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZXN1bHQsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgKG9wdHMgPyBvcHRzLm1lc3NhZ2UgOiAnJykgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5sb2NhbGl6YXRpb24gJiYgdGhpcy5sb2NhbGl6YXRpb25bdmFsaWRhdG9yXSAmJiB0aGlzLmxvY2FsaXphdGlvblt2YWxpZGF0b3JdWydkZWZhdWx0J11cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxvY2FsaXphdGlvblt2YWxpZGF0b3JdWydkZWZhdWx0J11cbiAgICAgICAgICAgICAgICAgICAgOiAnJykgfHxcbiAgICAgICAgICAgICAgICBcIlRoZSBmaWVsZCBcIi5jb25jYXQoZmllbGQsIFwiIGlzIG5vdCB2YWxpZFwiKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb3JlLnByb3RvdHlwZS50b2dnbGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoZW5hYmxlZCwgZmllbGQsIHZhbGlkYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdmFsaWRhdG9yQXJyID0gdGhpcy5maWVsZHNbZmllbGRdLnZhbGlkYXRvcnM7XG4gICAgICAgIGlmICh2YWxpZGF0b3IgJiYgdmFsaWRhdG9yQXJyICYmIHZhbGlkYXRvckFyclt2YWxpZGF0b3JdKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9yc1t2YWxpZGF0b3JdLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbGlkYXRvckFycikuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gKF90aGlzLmZpZWxkc1tmaWVsZF0udmFsaWRhdG9yc1t2XS5lbmFibGVkID0gZW5hYmxlZCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUZpZWxkU3RhdHVzKGZpZWxkLCAnTm90VmFsaWRhdGVkJywgdmFsaWRhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBDb3JlO1xufSgpKTtcbmZ1bmN0aW9uIGZvcm1WYWxpZGF0aW9uKGZvcm0sIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgZmllbGRzOiB7fSxcbiAgICAgICAgbG9jYWxlOiAnZW5fVVMnLFxuICAgICAgICBwbHVnaW5zOiB7fSxcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKF8pIHsgfSxcbiAgICB9LCBvcHRpb25zKTtcbiAgICB2YXIgY29yZSA9IG5ldyBDb3JlKGZvcm0sIG9wdHMuZmllbGRzKTtcbiAgICBjb3JlLnNldExvY2FsZShvcHRzLmxvY2FsZSwgb3B0cy5sb2NhbGl6YXRpb24pO1xuICAgIC8vIFJlZ2lzdGVyIHBsdWdpbnNcbiAgICBPYmplY3Qua2V5cyhvcHRzLnBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGNvcmUucmVnaXN0ZXJQbHVnaW4obmFtZSwgb3B0cy5wbHVnaW5zW25hbWVdKTsgfSk7XG4gICAgLy8gSXQncyB0aGUgc2luZ2xlIHBvaW50IHRoYXQgdXNlcnMgY2FuIGRvIGEgcGFydGljdWxhciB0YXNrIGJlZm9yZSBhZGRpbmcgZmllbGRzXG4gICAgLy8gU29tZSBpbml0aWFsaXphdGlvbiB0YXNrcyBtdXN0IGJlIGRvbmUgYXQgdGhhdCBwb2ludFxuICAgIG9wdHMuaW5pdChjb3JlKTtcbiAgICAvLyBhbmQgYWRkIGZpZWxkc1xuICAgIE9iamVjdC5rZXlzKG9wdHMuZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gY29yZS5hZGRGaWVsZChmaWVsZCwgb3B0cy5maWVsZHNbZmllbGRdKTsgfSk7XG4gICAgcmV0dXJuIGNvcmU7XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIFBsdWdpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbHVnaW4ob3B0cykge1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIFBsdWdpbi5wcm90b3R5cGUuc2V0Q29yZSA9IGZ1bmN0aW9uIChjb3JlKSB7XG4gICAgICAgIHRoaXMuY29yZSA9IGNvcmU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUGx1Z2luLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbkVuYWJsZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBQbHVnaW4ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25EaXNhYmxlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFBsdWdpbi5wcm90b3R5cGUuaXNQbHVnaW5FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuYWJsZWQ7XG4gICAgfTtcbiAgICBQbHVnaW4ucHJvdG90eXBlLm9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICBQbHVnaW4ucHJvdG90eXBlLm9uRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgUGx1Z2luLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkgeyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIFBsdWdpbi5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkgeyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIHJldHVybiBQbHVnaW47XG59KCkpO1xuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbi8qKlxuICogRXhlY3V0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbiB8IHN0cmluZ30gZnVuY3Rpb25OYW1lIENhbiBiZVxuICogLSBuYW1lIG9mIGdsb2JhbCBmdW5jdGlvblxuICogLSBuYW1lIG9mIG5hbWVzcGFjZSBmdW5jdGlvbiAoc3VjaCBhcyBBLkIuQylcbiAqIC0gYSBmdW5jdGlvblxuICogQHBhcmFtIHthbnlbXX0gYXJncyBUaGUgY2FsbGJhY2sgYXJndW1lbnRzXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGNhbGwoZnVuY3Rpb25OYW1lLCBhcmdzKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgLy8gTm9kZSB0aGF0IGl0IGRvZXNuJ3Qgc3VwcG9ydCBub2RlLmpzIGJhc2VkIGVudmlyb25tZW50IGJlY2F1c2Ugd2UgYXJlIHRyeWluZyB0byBhY2Nlc3MgYHdpbmRvd2BcbiAgICAgICAgdmFyIG5hbWVfMSA9IGZ1bmN0aW9uTmFtZTtcbiAgICAgICAgaWYgKCcoKScgPT09IG5hbWVfMS5zdWJzdHJpbmcobmFtZV8xLmxlbmd0aCAtIDIpKSB7XG4gICAgICAgICAgICBuYW1lXzEgPSBuYW1lXzEuc3Vic3RyaW5nKDAsIG5hbWVfMS5sZW5ndGggLSAyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnMgPSBuYW1lXzEuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGZ1bmMgPSBucy5wb3AoKTtcbiAgICAgICAgdmFyIGNvbnRleHRfMSA9IHdpbmRvdztcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuc18xID0gbnM7IF9pIDwgbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gbnNfMVtfaV07XG4gICAgICAgICAgICBjb250ZXh0XzEgPSBjb250ZXh0XzFbdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb250ZXh0XzFbZnVuY10gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNvbnRleHRfMVtmdW5jXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGFkZENsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzZXMpIHtcbiAgICBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhenopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiIFwiLmNvbmNhdChlbGVtZW50LmNsYXNzTmFtZSwgXCIgXCIpLmluZGV4T2YoXCIgXCIuY29uY2F0KGNsYXp6LCBcIiBcIikpKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIi5jb25jYXQoY2xhenopO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xudmFyIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzZXMpIHtcbiAgICBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhenopIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3RcbiAgICAgICAgICAgID8gZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXp6KVxuICAgICAgICAgICAgOiAoZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKGNsYXp6LCAnJykpO1xuICAgIH0pO1xufTtcbnZhciBjbGFzc1NldCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc2VzKSB7XG4gICAgdmFyIGFkZGluZyA9IFtdO1xuICAgIHZhciByZW1vdmluZyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNsYXNzZXMpLmZvckVhY2goZnVuY3Rpb24gKGNsYXp6KSB7XG4gICAgICAgIGlmIChjbGF6eikge1xuICAgICAgICAgICAgY2xhc3Nlc1tjbGF6el0gPyBhZGRpbmcucHVzaChjbGF6eikgOiByZW1vdmluZy5wdXNoKGNsYXp6KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFsd2F5cyByZW1vdmUgYmVmb3JlIGFkZGluZyBjbGFzcyBiZWNhdXNlIHRoZXJlIG1pZ2h0IGJlIGEgY2xhc3Mgd2hpY2ggYmVsb25nIHRvIGJvdGggc2V0cy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIGNsYXNzIGBhYCBhZnRlciBjYWxsaW5nXG4gICAgLy8gIGBgYFxuICAgIC8vICBjbGFzc1NldChlbGVtZW50LCB7XG4gICAgLy8gICAgICAnYSBhMSBhMic6IHRydWUsXG4gICAgLy8gICAgICAnYSBiMSBiMic6IGZhbHNlXG4gICAgLy8gIH0pXG4gICAgLy8gIGBgYFxuICAgIHJlbW92aW5nLmZvckVhY2goZnVuY3Rpb24gKGNsYXp6KSB7IHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGF6eik7IH0pO1xuICAgIGFkZGluZy5mb3JFYWNoKGZ1bmN0aW9uIChjbGF6eikgeyByZXR1cm4gYWRkQ2xhc3MoZWxlbWVudCwgY2xhenopOyB9KTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbmF0aXZlTWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2hlcyB8fFxuICAgICAgICBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICBlbGVtZW50Wydtb3pNYXRjaGVzU2VsZWN0b3InXSB8fFxuICAgICAgICBlbGVtZW50Wydtc01hdGNoZXNTZWxlY3RvciddO1xuICAgIGlmIChuYXRpdmVNYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVNYXRjaGVzLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICAvLyBJbiBjYXNlIGBtYXRjaGVzc2VsZWN0b3JgIGlzbid0IHN1cHBvcnRlZCAoc3VjaCBhcyBJRTEwKVxuICAgIC8vIFNlZSBodHRwOi8vY2FuaXVzZS5jb20vbWF0Y2hlc3NlbGVjdG9yXG4gICAgdmFyIG5vZGVzID0gW10uc2xpY2UuY2FsbChlbGVtZW50LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIHJldHVybiBub2Rlcy5pbmRleE9mKGVsZW1lbnQpID49IDA7XG59O1xudmFyIGNsb3Nlc3QgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlID0gZWxlbWVudDtcbiAgICB3aGlsZSAoZWxlKSB7XG4gICAgICAgIGlmIChtYXRjaGVzKGVsZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbGUgPSBlbGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGdlbmVyYXRlU3RyaW5nID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgIHJldHVybiBBcnJheShsZW5ndGgpXG4gICAgICAgIC5maWxsKCcnKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5jaGFyQXQoMik7IH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn07XG52YXIgZmV0Y2ggPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgdmFyIHRvUXVlcnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBcIlwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoayksIFwiPVwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrXSkpOyB9KVxuICAgICAgICAgICAgLmpvaW4oJyYnKTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgY3Jvc3NEb21haW46IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBwYXJhbXMgZm9yIEdFVCByZXF1ZXN0XG4gICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhvcHRzLnBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIFwiXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChrKSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQob3B0cy5wYXJhbXNba10pKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgICAgIHZhciBoYXNRdWVyeSA9IHVybC5pbmRleE9mKCc/JykgPiAtMTtcbiAgICAgICAgdmFyIHJlcXVlc3RVcmwgPSAnR0VUJyA9PT0gb3B0cy5tZXRob2QgPyBcIlwiLmNvbmNhdCh1cmwpLmNvbmNhdChoYXNRdWVyeSA/ICcmJyA6ICc/JykuY29uY2F0KHBhcmFtcykgOiB1cmw7XG4gICAgICAgIGlmIChvcHRzLmNyb3NzRG9tYWluKSB7XG4gICAgICAgICAgICAvLyBVc2VyIGlzIG1ha2luZyBjcm9zcyBkb21haW4gcmVxdWVzdFxuICAgICAgICAgICAgdmFyIHNjcmlwdF8xID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAvLyBJbiBzb21lIHZlcnkgZmFzdCBzeXN0ZW1zLCB0aGUgZGlmZmVyZW50IGBEYXRlLm5vdygpYCBpbnZvY2F0aW9ucyBjYW4gcmV0dXJuIHRoZSBzYW1lIHZhbHVlXG4gICAgICAgICAgICAvLyB3aGljaCBsZWFkcyB0byB0aGUgaXNzdWUgd2hlcmUgdGhlcmUgYXJlIG11bHRpcGxlIHJlbW92ZSB2YWxpZGF0b3JzIGFyZSB1c2VkLCBmb3IgZXhhbXBsZS5cbiAgICAgICAgICAgIC8vIEFwcGVuZGluZyBpdCB3aXRoIGEgZ2VuZXJhdGVkIHJhbmRvbSBzdHJpbmcgY2FuIGZpeCB0aGUgdmFsdWVcbiAgICAgICAgICAgIHZhciBjYWxsYmFja18xID0gXCJfX19Gb3JtVmFsaWRhdGlvbkZldGNoX1wiLmNvbmNhdChnZW5lcmF0ZVN0cmluZygxMiksIFwiX19fXCIpO1xuICAgICAgICAgICAgd2luZG93W2NhbGxiYWNrXzFdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93W2NhbGxiYWNrXzFdO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NyaXB0XzEuc3JjID0gXCJcIi5jb25jYXQocmVxdWVzdFVybCkuY29uY2F0KGhhc1F1ZXJ5ID8gJyYnIDogJz8nLCBcImNhbGxiYWNrPVwiKS5jb25jYXQoY2FsbGJhY2tfMSk7XG4gICAgICAgICAgICBzY3JpcHRfMS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICBzY3JpcHRfMS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNjcmlwdF8xLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0XzEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY3JpcHRfMS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlamVjdDsgfSk7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdF8xKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0XzEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcXVlc3RfMS5vcGVuKG9wdHMubWV0aG9kLCByZXF1ZXN0VXJsKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaGVhZGVyc1xuICAgICAgICAgICAgcmVxdWVzdF8xLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKTtcbiAgICAgICAgICAgIGlmICgnUE9TVCcgPT09IG9wdHMubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF8xLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdHMuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyByZXR1cm4gcmVxdWVzdF8xLnNldFJlcXVlc3RIZWFkZXIoaywgb3B0cy5oZWFkZXJzW2tdKTsgfSk7XG4gICAgICAgICAgICByZXF1ZXN0XzEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgdXNlIGFycm93IGZ1bmN0aW9uIGhlcmUgZHVlIHRvIHRoZSBgdGhpc2Agc2NvcGVcbiAgICAgICAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UodGhpcy5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdF8xLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0OyB9KTtcbiAgICAgICAgICAgIC8vIEdFVCByZXF1ZXN0IHdpbGwgaWdub3JlIHRoZSBwYXNzZWQgZGF0YSBoZXJlXG4gICAgICAgICAgICByZXF1ZXN0XzEuc2VuZCh0b1F1ZXJ5KG9wdHMucGFyYW1zKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBGb3JtYXQgYSBzdHJpbmdcbiAqIEl0J3MgdXNlZCB0byBmb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2VcbiAqIGZvcm1hdCgnVGhlIGZpZWxkIG11c3QgYmV0d2VlbiAlcyBhbmQgJXMnLCBbMTAsIDIwXSkgPSAnVGhlIGZpZWxkIG11c3QgYmV0d2VlbiAxMCBhbmQgMjAnXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgcGFyYW1zID0gQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSA/IHBhcmFtZXRlcnMgOiBbcGFyYW1ldGVyc107XG4gICAgdmFyIG91dHB1dCA9IG1lc3NhZ2U7XG4gICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoJyVzJywgcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXp6KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0XG4gICAgICAgID8gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhenopXG4gICAgICAgIDogbmV3IFJlZ0V4cChcIihefCApXCIuY29uY2F0KGNsYXp6LCBcIiggfCQpXCIpLCAnZ2knKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xuLyoqXG4gKiBWYWxpZGF0ZSBhIGRhdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30geWVhciBUaGUgZnVsbCB5ZWFyIGluIDQgZGlnaXRzXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9udGggVGhlIG1vbnRoIG51bWJlclxuICogQHBhcmFtIHtzdHJpbmd9IGRheSBUaGUgZGF5IG51bWJlclxuICogQHBhcmFtIHtib29sZWFufSBbbm90SW5GdXR1cmVdIElmIHRydWUsIHRoZSBkYXRlIG11c3Qgbm90IGJlIGluIHRoZSBmdXR1cmVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNWYWxpZERhdGUgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgsIGRheSwgbm90SW5GdXR1cmUpIHtcbiAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpIHx8IGlzTmFOKGRheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoeWVhciA8IDEwMDAgfHwgeWVhciA+IDk5OTkgfHwgbW9udGggPD0gMCB8fCBtb250aCA+IDEyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG51bURheXMgPSBbXG4gICAgICAgIDMxLFxuICAgICAgICAvLyBVcGRhdGUgdGhlIG51bWJlciBvZiBkYXlzIGluIEZlYiBvZiBsZWFwIHllYXJcbiAgICAgICAgeWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDEwMCAhPT0gMCAmJiB5ZWFyICUgNCA9PT0gMCkgPyAyOSA6IDI4LFxuICAgICAgICAzMSxcbiAgICAgICAgMzAsXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMxLFxuICAgICAgICAzMCxcbiAgICAgICAgMzEsXG4gICAgICAgIDMwLFxuICAgICAgICAzMSxcbiAgICBdO1xuICAgIC8vIENoZWNrIHRoZSBkYXlcbiAgICBpZiAoZGF5IDw9IDAgfHwgZGF5ID4gbnVtRGF5c1ttb250aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vdEluRnV0dXJlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50WWVhciA9IGN1cnJlbnREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIHZhciBjdXJyZW50TW9udGggPSBjdXJyZW50RGF0ZS5nZXRNb250aCgpO1xuICAgICAgICB2YXIgY3VycmVudERheSA9IGN1cnJlbnREYXRlLmdldERhdGUoKTtcbiAgICAgICAgcmV0dXJuICh5ZWFyIDwgY3VycmVudFllYXIgfHxcbiAgICAgICAgICAgICh5ZWFyID09PSBjdXJyZW50WWVhciAmJiBtb250aCAtIDEgPCBjdXJyZW50TW9udGgpIHx8XG4gICAgICAgICAgICAoeWVhciA9PT0gY3VycmVudFllYXIgJiYgbW9udGggLSAxID09PSBjdXJyZW50TW9udGggJiYgZGF5IDwgY3VycmVudERheSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIHJlbW92ZVVuZGVmaW5lZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqXG4gICAgICAgID8gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIF9hKSB7XG4gICAgICAgICAgICB2YXIgayA9IF9hWzBdLCB2ID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gKHYgPT09IHVuZGVmaW5lZCA/IGEgOiAoKGFba10gPSB2KSwgYSkpO1xuICAgICAgICB9LCB7fSlcbiAgICAgICAgOiB7fTtcbn07XG5cbi8qKlxuICogRm9ybVZhbGlkYXRpb24gKGh0dHBzOi8vZm9ybXZhbGlkYXRpb24uaW8pXG4gKiBUaGUgYmVzdCB2YWxpZGF0aW9uIGxpYnJhcnkgZm9yIEphdmFTY3JpcHRcbiAqIChjKSAyMDEzIC0gMjAyMyBOZ3V5ZW4gSHV1IFBodW9jIDxtZUBwaHVvYy5uZz5cbiAqL1xudmFyIGluZGV4ID0ge1xuICAgIGNhbGw6IGNhbGwsXG4gICAgY2xhc3NTZXQ6IGNsYXNzU2V0LFxuICAgIGNsb3Nlc3Q6IGNsb3Nlc3QsXG4gICAgZmV0Y2g6IGZldGNoLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICBpc1ZhbGlkRGF0ZTogaXNWYWxpZERhdGUsXG4gICAgcmVtb3ZlVW5kZWZpbmVkOiByZW1vdmVVbmRlZmluZWQsXG59O1xuXG5leHBvcnRzLlBsdWdpbiA9IFBsdWdpbjtcbmV4cG9ydHMuYWxnb3JpdGhtcyA9IGluZGV4JDE7XG5leHBvcnRzLmZvcm1WYWxpZGF0aW9uID0gZm9ybVZhbGlkYXRpb247XG5leHBvcnRzLnV0aWxzID0gaW5kZXg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/core/lib/cjs/index.js\n");

/***/ }),

/***/ "../node_modules/@form-validation/core/lib/index.js":
/*!**********************************************************!*\
  !*** ../node_modules/@form-validation/core/lib/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/index.js */ \"../node_modules/@form-validation/core/lib/cjs/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vY29yZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLElBQUksb0hBQTBDO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZm9ybS12YWxpZGF0aW9uL2NvcmUvbGliL2luZGV4LmpzPzg5MzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4Lm1pbi5qcycpO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/core/lib/index.js\n");

/***/ }),

/***/ "../node_modules/@form-validation/plugin-framework/lib/cjs/index.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@form-validation/plugin-framework/lib/cjs/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar core = __webpack_require__(/*! @form-validation/core */ \"../node_modules/@form-validation/core/lib/index.js\");\nvar pluginMessage = __webpack_require__(/*! @form-validation/plugin-message */ \"../node_modules/@form-validation/plugin-message/lib/index.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar classSet = core.utils.classSet, closest = core.utils.closest;\nvar Framework = /** @class */ (function (_super) {\n    __extends(Framework, _super);\n    function Framework(opts) {\n        var _this = _super.call(this, opts) || this;\n        _this.results = new Map();\n        _this.containers = new Map();\n        _this.opts = Object.assign({}, {\n            defaultMessageContainer: true,\n            eleInvalidClass: '',\n            eleValidClass: '',\n            rowClasses: '',\n            rowValidatingClass: '',\n        }, opts);\n        _this.elementIgnoredHandler = _this.onElementIgnored.bind(_this);\n        _this.elementValidatingHandler = _this.onElementValidating.bind(_this);\n        _this.elementValidatedHandler = _this.onElementValidated.bind(_this);\n        _this.elementNotValidatedHandler = _this.onElementNotValidated.bind(_this);\n        _this.iconPlacedHandler = _this.onIconPlaced.bind(_this);\n        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n        _this.messagePlacedHandler = _this.onMessagePlaced.bind(_this);\n        return _this;\n    }\n    Framework.prototype.install = function () {\n        var _a;\n        var _this = this;\n        classSet(this.core.getFormElement(), (_a = {},\n            _a[this.opts.formClass] = true,\n            _a['fv-plugins-framework'] = true,\n            _a));\n        this.core\n            .on('core.element.ignored', this.elementIgnoredHandler)\n            .on('core.element.validating', this.elementValidatingHandler)\n            .on('core.element.validated', this.elementValidatedHandler)\n            .on('core.element.notvalidated', this.elementNotValidatedHandler)\n            .on('plugins.icon.placed', this.iconPlacedHandler)\n            .on('core.field.added', this.fieldAddedHandler)\n            .on('core.field.removed', this.fieldRemovedHandler);\n        if (this.opts.defaultMessageContainer) {\n            this.core.registerPlugin(Framework.MESSAGE_PLUGIN, new pluginMessage.Message({\n                clazz: this.opts.messageClass,\n                container: function (field, element) {\n                    var selector = 'string' === typeof _this.opts.rowSelector\n                        ? _this.opts.rowSelector\n                        : _this.opts.rowSelector(field, element);\n                    var groupEle = closest(element, selector);\n                    return pluginMessage.Message.getClosestContainer(element, groupEle, _this.opts.rowPattern);\n                },\n            }));\n            this.core.on('plugins.message.placed', this.messagePlacedHandler);\n        }\n    };\n    Framework.prototype.uninstall = function () {\n        var _a;\n        this.results.clear();\n        this.containers.clear();\n        classSet(this.core.getFormElement(), (_a = {},\n            _a[this.opts.formClass] = false,\n            _a['fv-plugins-framework'] = false,\n            _a));\n        this.core\n            .off('core.element.ignored', this.elementIgnoredHandler)\n            .off('core.element.validating', this.elementValidatingHandler)\n            .off('core.element.validated', this.elementValidatedHandler)\n            .off('core.element.notvalidated', this.elementNotValidatedHandler)\n            .off('plugins.icon.placed', this.iconPlacedHandler)\n            .off('core.field.added', this.fieldAddedHandler)\n            .off('core.field.removed', this.fieldRemovedHandler);\n        if (this.opts.defaultMessageContainer) {\n            this.core.deregisterPlugin(Framework.MESSAGE_PLUGIN);\n            this.core.off('plugins.message.placed', this.messagePlacedHandler);\n        }\n    };\n    Framework.prototype.onEnabled = function () {\n        var _a;\n        classSet(this.core.getFormElement(), (_a = {},\n            _a[this.opts.formClass] = true,\n            _a));\n        if (this.opts.defaultMessageContainer) {\n            this.core.enablePlugin(Framework.MESSAGE_PLUGIN);\n        }\n    };\n    Framework.prototype.onDisabled = function () {\n        var _a;\n        classSet(this.core.getFormElement(), (_a = {},\n            _a[this.opts.formClass] = false,\n            _a));\n        if (this.opts.defaultMessageContainer) {\n            this.core.disablePlugin(Framework.MESSAGE_PLUGIN);\n        }\n    };\n    Framework.prototype.onIconPlaced = function (_e) { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Framework.prototype.onMessagePlaced = function (_e) { }; // eslint-disable-line @typescript-eslint/no-empty-function\n    Framework.prototype.onFieldAdded = function (e) {\n        var _this = this;\n        var elements = e.elements;\n        if (elements) {\n            elements.forEach(function (ele) {\n                var _a;\n                var groupEle = _this.containers.get(ele);\n                if (groupEle) {\n                    classSet(groupEle, (_a = {},\n                        _a[_this.opts.rowInvalidClass] = false,\n                        _a[_this.opts.rowValidatingClass] = false,\n                        _a[_this.opts.rowValidClass] = false,\n                        _a['fv-plugins-icon-container'] = false,\n                        _a));\n                    _this.containers.delete(ele);\n                }\n            });\n            this.prepareFieldContainer(e.field, elements);\n        }\n    };\n    Framework.prototype.onFieldRemoved = function (e) {\n        var _this = this;\n        e.elements.forEach(function (ele) {\n            var _a;\n            var groupEle = _this.containers.get(ele);\n            if (groupEle) {\n                classSet(groupEle, (_a = {},\n                    _a[_this.opts.rowInvalidClass] = false,\n                    _a[_this.opts.rowValidatingClass] = false,\n                    _a[_this.opts.rowValidClass] = false,\n                    _a));\n            }\n        });\n    };\n    Framework.prototype.prepareFieldContainer = function (field, elements) {\n        var _this = this;\n        if (elements.length) {\n            var type = elements[0].getAttribute('type');\n            if ('radio' === type || 'checkbox' === type) {\n                this.prepareElementContainer(field, elements[0]);\n            }\n            else {\n                elements.forEach(function (ele) { return _this.prepareElementContainer(field, ele); });\n            }\n        }\n    };\n    Framework.prototype.prepareElementContainer = function (field, element) {\n        var _a;\n        var selector = 'string' === typeof this.opts.rowSelector ? this.opts.rowSelector : this.opts.rowSelector(field, element);\n        var groupEle = closest(element, selector);\n        if (groupEle !== element) {\n            classSet(groupEle, (_a = {},\n                _a[this.opts.rowClasses] = true,\n                _a['fv-plugins-icon-container'] = true,\n                _a));\n            this.containers.set(element, groupEle);\n        }\n    };\n    Framework.prototype.onElementValidating = function (e) {\n        this.removeClasses(e.element, e.elements);\n    };\n    Framework.prototype.onElementNotValidated = function (e) {\n        this.removeClasses(e.element, e.elements);\n    };\n    Framework.prototype.onElementIgnored = function (e) {\n        this.removeClasses(e.element, e.elements);\n    };\n    Framework.prototype.removeClasses = function (element, elements) {\n        var _a;\n        var _this = this;\n        var type = element.getAttribute('type');\n        var ele = 'radio' === type || 'checkbox' === type ? elements[0] : element;\n        elements.forEach(function (ele) {\n            var _a;\n            classSet(ele, (_a = {},\n                _a[_this.opts.eleValidClass] = false,\n                _a[_this.opts.eleInvalidClass] = false,\n                _a));\n        });\n        var groupEle = this.containers.get(ele);\n        if (groupEle) {\n            classSet(groupEle, (_a = {},\n                _a[this.opts.rowInvalidClass] = false,\n                _a[this.opts.rowValidatingClass] = false,\n                _a[this.opts.rowValidClass] = false,\n                _a));\n        }\n    };\n    Framework.prototype.onElementValidated = function (e) {\n        var _a, _b;\n        var _this = this;\n        var elements = e.elements;\n        var type = e.element.getAttribute('type');\n        var element = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n        // Set the valid or invalid class for all elements\n        elements.forEach(function (ele) {\n            var _a;\n            classSet(ele, (_a = {},\n                _a[_this.opts.eleValidClass] = e.valid,\n                _a[_this.opts.eleInvalidClass] = !e.valid,\n                _a));\n        });\n        var groupEle = this.containers.get(element);\n        if (groupEle) {\n            if (!e.valid) {\n                this.results.set(element, false);\n                classSet(groupEle, (_a = {},\n                    _a[this.opts.rowInvalidClass] = true,\n                    _a[this.opts.rowValidatingClass] = false,\n                    _a[this.opts.rowValidClass] = false,\n                    _a));\n            }\n            else {\n                this.results.delete(element);\n                // Maybe there're multiple fields belong to the same row\n                var isValid_1 = true;\n                this.containers.forEach(function (value, key) {\n                    if (value === groupEle && _this.results.get(key) === false) {\n                        isValid_1 = false;\n                    }\n                });\n                // If all field(s) belonging to the row are valid\n                if (isValid_1) {\n                    classSet(groupEle, (_b = {},\n                        _b[this.opts.rowInvalidClass] = false,\n                        _b[this.opts.rowValidatingClass] = false,\n                        _b[this.opts.rowValidClass] = true,\n                        _b));\n                }\n            }\n        }\n    };\n    Framework.MESSAGE_PLUGIN = '___frameworkMessage';\n    return Framework;\n}(core.Plugin));\n\nexports.Framework = Framework;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWZyYW1ld29yay9saWIvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxpRkFBdUI7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMscUdBQWlDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsbURBQW1EO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWZyYW1ld29yay9saWIvY2pzL2luZGV4LmpzPzg5YTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0Bmb3JtLXZhbGlkYXRpb24vY29yZScpO1xudmFyIHBsdWdpbk1lc3NhZ2UgPSByZXF1aXJlKCdAZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1tZXNzYWdlJyk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxuXG4vKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cbnZhciBjbGFzc1NldCA9IGNvcmUudXRpbHMuY2xhc3NTZXQsIGNsb3Nlc3QgPSBjb3JlLnV0aWxzLmNsb3Nlc3Q7XG52YXIgRnJhbWV3b3JrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcmFtZXdvcmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJhbWV3b3JrKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIGRlZmF1bHRNZXNzYWdlQ29udGFpbmVyOiB0cnVlLFxuICAgICAgICAgICAgZWxlSW52YWxpZENsYXNzOiAnJyxcbiAgICAgICAgICAgIGVsZVZhbGlkQ2xhc3M6ICcnLFxuICAgICAgICAgICAgcm93Q2xhc3NlczogJycsXG4gICAgICAgICAgICByb3dWYWxpZGF0aW5nQ2xhc3M6ICcnLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgX3RoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyID0gX3RoaXMub25FbGVtZW50SWdub3JlZC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyID0gX3RoaXMub25FbGVtZW50VmFsaWRhdGluZy5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZWxlbWVudFZhbGlkYXRlZEhhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnRWYWxpZGF0ZWQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmVsZW1lbnROb3RWYWxpZGF0ZWRIYW5kbGVyID0gX3RoaXMub25FbGVtZW50Tm90VmFsaWRhdGVkLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5pY29uUGxhY2VkSGFuZGxlciA9IF90aGlzLm9uSWNvblBsYWNlZC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZmllbGRBZGRlZEhhbmRsZXIgPSBfdGhpcy5vbkZpZWxkQWRkZWQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLmZpZWxkUmVtb3ZlZEhhbmRsZXIgPSBfdGhpcy5vbkZpZWxkUmVtb3ZlZC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMubWVzc2FnZVBsYWNlZEhhbmRsZXIgPSBfdGhpcy5vbk1lc3NhZ2VQbGFjZWQuYmluZChfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnJhbWV3b3JrLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNsYXNzU2V0KHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLCAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW3RoaXMub3B0cy5mb3JtQ2xhc3NdID0gdHJ1ZSxcbiAgICAgICAgICAgIF9hWydmdi1wbHVnaW5zLWZyYW1ld29yayddID0gdHJ1ZSxcbiAgICAgICAgICAgIF9hKSk7XG4gICAgICAgIHRoaXMuY29yZVxuICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQuaWdub3JlZCcsIHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGluZycsIHRoaXMuZWxlbWVudFZhbGlkYXRpbmdIYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdjb3JlLmVsZW1lbnQudmFsaWRhdGVkJywgdGhpcy5lbGVtZW50VmFsaWRhdGVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vbignY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZCcsIHRoaXMuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXIpXG4gICAgICAgICAgICAub24oJ3BsdWdpbnMuaWNvbi5wbGFjZWQnLCB0aGlzLmljb25QbGFjZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vbignY29yZS5maWVsZC5yZW1vdmVkJywgdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kZWZhdWx0TWVzc2FnZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5jb3JlLnJlZ2lzdGVyUGx1Z2luKEZyYW1ld29yay5NRVNTQUdFX1BMVUdJTiwgbmV3IHBsdWdpbk1lc3NhZ2UuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgY2xheno6IHRoaXMub3B0cy5tZXNzYWdlQ2xhc3MsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBmdW5jdGlvbiAoZmllbGQsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gJ3N0cmluZycgPT09IHR5cGVvZiBfdGhpcy5vcHRzLnJvd1NlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF90aGlzLm9wdHMucm93U2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3RoaXMub3B0cy5yb3dTZWxlY3RvcihmaWVsZCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cEVsZSA9IGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luTWVzc2FnZS5NZXNzYWdlLmdldENsb3Nlc3RDb250YWluZXIoZWxlbWVudCwgZ3JvdXBFbGUsIF90aGlzLm9wdHMucm93UGF0dGVybik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMuY29yZS5vbigncGx1Z2lucy5tZXNzYWdlLnBsYWNlZCcsIHRoaXMubWVzc2FnZVBsYWNlZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGcmFtZXdvcmsucHJvdG90eXBlLnVuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnJlc3VsdHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJzLmNsZWFyKCk7XG4gICAgICAgIGNsYXNzU2V0KHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLCAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW3RoaXMub3B0cy5mb3JtQ2xhc3NdID0gZmFsc2UsXG4gICAgICAgICAgICBfYVsnZnYtcGx1Z2lucy1mcmFtZXdvcmsnXSA9IGZhbHNlLFxuICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgdGhpcy5jb3JlXG4gICAgICAgICAgICAub2ZmKCdjb3JlLmVsZW1lbnQuaWdub3JlZCcsIHRoaXMuZWxlbWVudElnbm9yZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50LnZhbGlkYXRpbmcnLCB0aGlzLmVsZW1lbnRWYWxpZGF0aW5nSGFuZGxlcilcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC52YWxpZGF0ZWQnLCB0aGlzLmVsZW1lbnRWYWxpZGF0ZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9mZignY29yZS5lbGVtZW50Lm5vdHZhbGlkYXRlZCcsIHRoaXMuZWxlbWVudE5vdFZhbGlkYXRlZEhhbmRsZXIpXG4gICAgICAgICAgICAub2ZmKCdwbHVnaW5zLmljb24ucGxhY2VkJywgdGhpcy5pY29uUGxhY2VkSGFuZGxlcilcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUuZmllbGQuYWRkZWQnLCB0aGlzLmZpZWxkQWRkZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9mZignY29yZS5maWVsZC5yZW1vdmVkJywgdGhpcy5maWVsZFJlbW92ZWRIYW5kbGVyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kZWZhdWx0TWVzc2FnZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5jb3JlLmRlcmVnaXN0ZXJQbHVnaW4oRnJhbWV3b3JrLk1FU1NBR0VfUExVR0lOKTtcbiAgICAgICAgICAgIHRoaXMuY29yZS5vZmYoJ3BsdWdpbnMubWVzc2FnZS5wbGFjZWQnLCB0aGlzLm1lc3NhZ2VQbGFjZWRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRnJhbWV3b3JrLnByb3RvdHlwZS5vbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2xhc3NTZXQodGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCksIChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbdGhpcy5vcHRzLmZvcm1DbGFzc10gPSB0cnVlLFxuICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kZWZhdWx0TWVzc2FnZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5jb3JlLmVuYWJsZVBsdWdpbihGcmFtZXdvcmsuTUVTU0FHRV9QTFVHSU4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY2xhc3NTZXQodGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCksIChfYSA9IHt9LFxuICAgICAgICAgICAgX2FbdGhpcy5vcHRzLmZvcm1DbGFzc10gPSBmYWxzZSxcbiAgICAgICAgICAgIF9hKSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZGVmYXVsdE1lc3NhZ2VDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29yZS5kaXNhYmxlUGx1Z2luKEZyYW1ld29yay5NRVNTQUdFX1BMVUdJTik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZyYW1ld29yay5wcm90b3R5cGUub25JY29uUGxhY2VkID0gZnVuY3Rpb24gKF9lKSB7IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gICAgRnJhbWV3b3JrLnByb3RvdHlwZS5vbk1lc3NhZ2VQbGFjZWQgPSBmdW5jdGlvbiAoX2UpIHsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uRmllbGRBZGRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGUuZWxlbWVudHM7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBncm91cEVsZSA9IF90aGlzLmNvbnRhaW5lcnMuZ2V0KGVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwRWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzU2V0KGdyb3VwRWxlLCAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hW190aGlzLm9wdHMucm93SW52YWxpZENsYXNzXSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5yb3dWYWxpZGF0aW5nQ2xhc3NdID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYVtfdGhpcy5vcHRzLnJvd1ZhbGlkQ2xhc3NdID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYVsnZnYtcGx1Z2lucy1pY29uLWNvbnRhaW5lciddID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250YWluZXJzLmRlbGV0ZShlbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlRmllbGRDb250YWluZXIoZS5maWVsZCwgZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uRmllbGRSZW1vdmVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZS5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBncm91cEVsZSA9IF90aGlzLmNvbnRhaW5lcnMuZ2V0KGVsZSk7XG4gICAgICAgICAgICBpZiAoZ3JvdXBFbGUpIHtcbiAgICAgICAgICAgICAgICBjbGFzc1NldChncm91cEVsZSwgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgIF9hW190aGlzLm9wdHMucm93SW52YWxpZENsYXNzXSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBfYVtfdGhpcy5vcHRzLnJvd1ZhbGlkYXRpbmdDbGFzc10gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5yb3dWYWxpZENsYXNzXSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZyYW1ld29yay5wcm90b3R5cGUucHJlcGFyZUZpZWxkQ29udGFpbmVyID0gZnVuY3Rpb24gKGZpZWxkLCBlbGVtZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGVsZW1lbnRzWzBdLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgaWYgKCdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZUVsZW1lbnRDb250YWluZXIoZmllbGQsIGVsZW1lbnRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkgeyByZXR1cm4gX3RoaXMucHJlcGFyZUVsZW1lbnRDb250YWluZXIoZmllbGQsIGVsZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGcmFtZXdvcmsucHJvdG90eXBlLnByZXBhcmVFbGVtZW50Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpZWxkLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gJ3N0cmluZycgPT09IHR5cGVvZiB0aGlzLm9wdHMucm93U2VsZWN0b3IgPyB0aGlzLm9wdHMucm93U2VsZWN0b3IgOiB0aGlzLm9wdHMucm93U2VsZWN0b3IoZmllbGQsIGVsZW1lbnQpO1xuICAgICAgICB2YXIgZ3JvdXBFbGUgPSBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKGdyb3VwRWxlICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICBjbGFzc1NldChncm91cEVsZSwgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgX2FbdGhpcy5vcHRzLnJvd0NsYXNzZXNdID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBfYVsnZnYtcGx1Z2lucy1pY29uLWNvbnRhaW5lciddID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJzLnNldChlbGVtZW50LCBncm91cEVsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZyYW1ld29yay5wcm90b3R5cGUub25FbGVtZW50VmFsaWRhdGluZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3NlcyhlLmVsZW1lbnQsIGUuZWxlbWVudHMpO1xuICAgIH07XG4gICAgRnJhbWV3b3JrLnByb3RvdHlwZS5vbkVsZW1lbnROb3RWYWxpZGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzZXMoZS5lbGVtZW50LCBlLmVsZW1lbnRzKTtcbiAgICB9O1xuICAgIEZyYW1ld29yay5wcm90b3R5cGUub25FbGVtZW50SWdub3JlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2xhc3NlcyhlLmVsZW1lbnQsIGUuZWxlbWVudHMpO1xuICAgIH07XG4gICAgRnJhbWV3b3JrLnByb3RvdHlwZS5yZW1vdmVDbGFzc2VzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICB2YXIgZWxlID0gJ3JhZGlvJyA9PT0gdHlwZSB8fCAnY2hlY2tib3gnID09PSB0eXBlID8gZWxlbWVudHNbMF0gOiBlbGVtZW50O1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNsYXNzU2V0KGVsZSwgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5lbGVWYWxpZENsYXNzXSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIF9hW190aGlzLm9wdHMuZWxlSW52YWxpZENsYXNzXSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIF9hKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZ3JvdXBFbGUgPSB0aGlzLmNvbnRhaW5lcnMuZ2V0KGVsZSk7XG4gICAgICAgIGlmIChncm91cEVsZSkge1xuICAgICAgICAgICAgY2xhc3NTZXQoZ3JvdXBFbGUsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgIF9hW3RoaXMub3B0cy5yb3dJbnZhbGlkQ2xhc3NdID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgX2FbdGhpcy5vcHRzLnJvd1ZhbGlkYXRpbmdDbGFzc10gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBfYVt0aGlzLm9wdHMucm93VmFsaWRDbGFzc10gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGcmFtZXdvcmsucHJvdG90eXBlLm9uRWxlbWVudFZhbGlkYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGUuZWxlbWVudHM7XG4gICAgICAgIHZhciB0eXBlID0gZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICB2YXIgZWxlbWVudCA9ICdyYWRpbycgPT09IHR5cGUgfHwgJ2NoZWNrYm94JyA9PT0gdHlwZSA/IGVsZW1lbnRzWzBdIDogZS5lbGVtZW50O1xuICAgICAgICAvLyBTZXQgdGhlIHZhbGlkIG9yIGludmFsaWQgY2xhc3MgZm9yIGFsbCBlbGVtZW50c1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNsYXNzU2V0KGVsZSwgKF9hID0ge30sXG4gICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5lbGVWYWxpZENsYXNzXSA9IGUudmFsaWQsXG4gICAgICAgICAgICAgICAgX2FbX3RoaXMub3B0cy5lbGVJbnZhbGlkQ2xhc3NdID0gIWUudmFsaWQsXG4gICAgICAgICAgICAgICAgX2EpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBncm91cEVsZSA9IHRoaXMuY29udGFpbmVycy5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChncm91cEVsZSkge1xuICAgICAgICAgICAgaWYgKCFlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLnNldChlbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgY2xhc3NTZXQoZ3JvdXBFbGUsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVt0aGlzLm9wdHMucm93SW52YWxpZENsYXNzXSA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIF9hW3RoaXMub3B0cy5yb3dWYWxpZGF0aW5nQ2xhc3NdID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIF9hW3RoaXMub3B0cy5yb3dWYWxpZENsYXNzXSA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAvLyBNYXliZSB0aGVyZSdyZSBtdWx0aXBsZSBmaWVsZHMgYmVsb25nIHRvIHRoZSBzYW1lIHJvd1xuICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZ3JvdXBFbGUgJiYgX3RoaXMucmVzdWx0cy5nZXQoa2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgYWxsIGZpZWxkKHMpIGJlbG9uZ2luZyB0byB0aGUgcm93IGFyZSB2YWxpZFxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NTZXQoZ3JvdXBFbGUsIChfYiA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2JbdGhpcy5vcHRzLnJvd0ludmFsaWRDbGFzc10gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW3RoaXMub3B0cy5yb3dWYWxpZGF0aW5nQ2xhc3NdID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYlt0aGlzLm9wdHMucm93VmFsaWRDbGFzc10gPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZyYW1ld29yay5NRVNTQUdFX1BMVUdJTiA9ICdfX19mcmFtZXdvcmtNZXNzYWdlJztcbiAgICByZXR1cm4gRnJhbWV3b3JrO1xufShjb3JlLlBsdWdpbikpO1xuXG5leHBvcnRzLkZyYW1ld29yayA9IEZyYW1ld29yaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/plugin-framework/lib/cjs/index.js\n");

/***/ }),

/***/ "../node_modules/@form-validation/plugin-framework/lib/index.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@form-validation/plugin-framework/lib/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/index.js */ \"../node_modules/@form-validation/plugin-framework/lib/cjs/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWZyYW1ld29yay9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLElBQUksZ0lBQTBDO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1mcmFtZXdvcmsvbGliL2luZGV4LmpzP2RhMTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4Lm1pbi5qcycpO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL2luZGV4LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/plugin-framework/lib/index.js\n");

/***/ }),

/***/ "../node_modules/@form-validation/plugin-message/lib/cjs/index.js":
/*!************************************************************************!*\
  !*** ../node_modules/@form-validation/plugin-message/lib/cjs/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar core = __webpack_require__(/*! @form-validation/core */ \"../node_modules/@form-validation/core/lib/index.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar classSet = core.utils.classSet;\nvar Message = /** @class */ (function (_super) {\n    __extends(Message, _super);\n    function Message(opts) {\n        var _this = _super.call(this, opts) || this;\n        _this.useDefaultContainer = false;\n        // Map the field element to message container\n        _this.messages = new Map();\n        // By default, we will display error messages at the bottom of form\n        _this.defaultContainer = document.createElement('div');\n        _this.useDefaultContainer = !opts || !opts.container;\n        _this.opts = Object.assign({}, {\n            container: function (_field, _element) { return _this.defaultContainer; },\n        }, opts);\n        _this.elementIgnoredHandler = _this.onElementIgnored.bind(_this);\n        _this.fieldAddedHandler = _this.onFieldAdded.bind(_this);\n        _this.fieldRemovedHandler = _this.onFieldRemoved.bind(_this);\n        _this.validatorValidatedHandler = _this.onValidatorValidated.bind(_this);\n        _this.validatorNotValidatedHandler = _this.onValidatorNotValidated.bind(_this);\n        return _this;\n    }\n    /**\n     * Determine the closest element that its class matches with given pattern.\n     * In popular cases, all the fields might follow the same markup, so that closest element\n     * can be used as message container.\n     *\n     * For example, if we use the Bootstrap framework then the field often be placed inside a\n     * `col-{size}-{numberOfColumns}` class, we can register the plugin as following:\n     * ```\n     *  formValidation(form, {\n     *      plugins: {\n     *          message: new Message({\n     *              container: function(field, element) {\n     *                  return Message.getClosestContainer(element, form, /^(.*)(col|offset)-(xs|sm|md|lg)-[0-9]+(.*)$/)\n     *              }\n     *          })\n     *      }\n     *  })\n     * ```\n     *\n     * @param element The field element\n     * @param upper The upper element, so we don't have to look for the entire page\n     * @param pattern The pattern\n     * @return {HTMLElement}\n     */\n    Message.getClosestContainer = function (element, upper, pattern) {\n        var ele = element;\n        while (ele) {\n            if (ele === upper) {\n                break;\n            }\n            ele = ele.parentElement;\n            if (pattern.test(ele.className)) {\n                break;\n            }\n        }\n        return ele;\n    };\n    Message.prototype.install = function () {\n        if (this.useDefaultContainer) {\n            this.core.getFormElement().appendChild(this.defaultContainer);\n        }\n        this.core\n            .on('core.element.ignored', this.elementIgnoredHandler)\n            .on('core.field.added', this.fieldAddedHandler)\n            .on('core.field.removed', this.fieldRemovedHandler)\n            .on('core.validator.validated', this.validatorValidatedHandler)\n            .on('core.validator.notvalidated', this.validatorNotValidatedHandler);\n    };\n    Message.prototype.uninstall = function () {\n        if (this.useDefaultContainer) {\n            this.core.getFormElement().removeChild(this.defaultContainer);\n        }\n        this.messages.forEach(function (message) { return message.parentNode.removeChild(message); });\n        this.messages.clear();\n        this.core\n            .off('core.element.ignored', this.elementIgnoredHandler)\n            .off('core.field.added', this.fieldAddedHandler)\n            .off('core.field.removed', this.fieldRemovedHandler)\n            .off('core.validator.validated', this.validatorValidatedHandler)\n            .off('core.validator.notvalidated', this.validatorNotValidatedHandler);\n    };\n    Message.prototype.onEnabled = function () {\n        this.messages.forEach(function (_element, message, _map) {\n            classSet(message, {\n                'fv-plugins-message-container--enabled': true,\n                'fv-plugins-message-container--disabled': false,\n            });\n        });\n    };\n    Message.prototype.onDisabled = function () {\n        this.messages.forEach(function (_element, message, _map) {\n            classSet(message, {\n                'fv-plugins-message-container--enabled': false,\n                'fv-plugins-message-container--disabled': true,\n            });\n        });\n    };\n    // Prepare message container for new added field\n    Message.prototype.onFieldAdded = function (e) {\n        var _this = this;\n        var elements = e.elements;\n        if (elements) {\n            elements.forEach(function (ele) {\n                var msg = _this.messages.get(ele);\n                if (msg) {\n                    msg.parentNode.removeChild(msg);\n                    _this.messages.delete(ele);\n                }\n            });\n            this.prepareFieldContainer(e.field, elements);\n        }\n    };\n    // When a field is removed, we remove all error messages that associates with the field\n    Message.prototype.onFieldRemoved = function (e) {\n        var _this = this;\n        if (!e.elements.length || !e.field) {\n            return;\n        }\n        var type = e.elements[0].getAttribute('type');\n        var elements = 'radio' === type || 'checkbox' === type ? [e.elements[0]] : e.elements;\n        elements.forEach(function (ele) {\n            if (_this.messages.has(ele)) {\n                var container = _this.messages.get(ele);\n                container.parentNode.removeChild(container);\n                _this.messages.delete(ele);\n            }\n        });\n    };\n    Message.prototype.prepareFieldContainer = function (field, elements) {\n        var _this = this;\n        if (elements.length) {\n            var type = elements[0].getAttribute('type');\n            if ('radio' === type || 'checkbox' === type) {\n                this.prepareElementContainer(field, elements[0], elements);\n            }\n            else {\n                elements.forEach(function (ele) { return _this.prepareElementContainer(field, ele, elements); });\n            }\n        }\n    };\n    Message.prototype.prepareElementContainer = function (field, element, elements) {\n        var container;\n        if ('string' === typeof this.opts.container) {\n            var selector = '#' === this.opts.container.charAt(0)\n                ? \"[id=\\\"\".concat(this.opts.container.substring(1), \"\\\"]\")\n                : this.opts.container;\n            container = this.core.getFormElement().querySelector(selector);\n        }\n        else {\n            container = this.opts.container(field, element);\n        }\n        var message = document.createElement('div');\n        container.appendChild(message);\n        classSet(message, {\n            'fv-plugins-message-container': true,\n            'fv-plugins-message-container--enabled': this.isEnabled,\n            'fv-plugins-message-container--disabled': !this.isEnabled,\n        });\n        this.core.emit('plugins.message.placed', {\n            element: element,\n            elements: elements,\n            field: field,\n            messageElement: message,\n        });\n        this.messages.set(element, message);\n    };\n    Message.prototype.getMessage = function (result) {\n        return typeof result.message === 'string' ? result.message : result.message[this.core.getLocale()];\n    };\n    Message.prototype.onValidatorValidated = function (e) {\n        var _a;\n        var elements = e.elements;\n        var type = e.element.getAttribute('type');\n        var element = ('radio' === type || 'checkbox' === type) && elements.length > 0 ? elements[0] : e.element;\n        if (this.messages.has(element)) {\n            var container = this.messages.get(element);\n            var messageEle = container.querySelector(\"[data-field=\\\"\".concat(e.field.replace(/\"/g, '\\\\\"'), \"\\\"][data-validator=\\\"\").concat(e.validator.replace(/\"/g, '\\\\\"'), \"\\\"]\"));\n            if (!messageEle && !e.result.valid) {\n                var ele = document.createElement('div');\n                ele.innerHTML = this.getMessage(e.result);\n                ele.setAttribute('data-field', e.field);\n                ele.setAttribute('data-validator', e.validator);\n                if (this.opts.clazz) {\n                    classSet(ele, (_a = {},\n                        _a[this.opts.clazz] = true,\n                        _a));\n                }\n                container.appendChild(ele);\n                this.core.emit('plugins.message.displayed', {\n                    element: e.element,\n                    field: e.field,\n                    message: e.result.message,\n                    messageElement: ele,\n                    meta: e.result.meta,\n                    validator: e.validator,\n                });\n            }\n            else if (messageEle && !e.result.valid) {\n                // The validator returns new message\n                messageEle.innerHTML = this.getMessage(e.result);\n                this.core.emit('plugins.message.displayed', {\n                    element: e.element,\n                    field: e.field,\n                    message: e.result.message,\n                    messageElement: messageEle,\n                    meta: e.result.meta,\n                    validator: e.validator,\n                });\n            }\n            else if (messageEle && e.result.valid) {\n                // Field is valid\n                container.removeChild(messageEle);\n            }\n        }\n    };\n    Message.prototype.onValidatorNotValidated = function (e) {\n        var elements = e.elements;\n        var type = e.element.getAttribute('type');\n        var element = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n        if (this.messages.has(element)) {\n            var container = this.messages.get(element);\n            var messageEle = container.querySelector(\"[data-field=\\\"\".concat(e.field.replace(/\"/g, '\\\\\"'), \"\\\"][data-validator=\\\"\").concat(e.validator.replace(/\"/g, '\\\\\"'), \"\\\"]\"));\n            if (messageEle) {\n                container.removeChild(messageEle);\n            }\n        }\n    };\n    Message.prototype.onElementIgnored = function (e) {\n        var elements = e.elements;\n        var type = e.element.getAttribute('type');\n        var element = 'radio' === type || 'checkbox' === type ? elements[0] : e.element;\n        if (this.messages.has(element)) {\n            var container_1 = this.messages.get(element);\n            var messageElements = [].slice.call(container_1.querySelectorAll(\"[data-field=\\\"\".concat(e.field.replace(/\"/g, '\\\\\"'), \"\\\"]\")));\n            messageElements.forEach(function (messageEle) {\n                container_1.removeChild(messageEle);\n            });\n        }\n    };\n    return Message;\n}(core.Plugin));\n\nexports.Message = Message;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLW1lc3NhZ2UvbGliL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsaUZBQXVCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFEQUFxRCxnQ0FBZ0M7QUFDckYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLLEVBQUUsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpREFBaUQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZEQUE2RDtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tbWVzc2FnZS9saWIvY2pzL2luZGV4LmpzP2QwODgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0Bmb3JtLXZhbGlkYXRpb24vY29yZScpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG52YXIgY2xhc3NTZXQgPSBjb3JlLnV0aWxzLmNsYXNzU2V0O1xudmFyIE1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lc3NhZ2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVzc2FnZShvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVzZURlZmF1bHRDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gTWFwIHRoZSBmaWVsZCBlbGVtZW50IHRvIG1lc3NhZ2UgY29udGFpbmVyXG4gICAgICAgIF90aGlzLm1lc3NhZ2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBCeSBkZWZhdWx0LCB3ZSB3aWxsIGRpc3BsYXkgZXJyb3IgbWVzc2FnZXMgYXQgdGhlIGJvdHRvbSBvZiBmb3JtXG4gICAgICAgIF90aGlzLmRlZmF1bHRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgX3RoaXMudXNlRGVmYXVsdENvbnRhaW5lciA9ICFvcHRzIHx8ICFvcHRzLmNvbnRhaW5lcjtcbiAgICAgICAgX3RoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogZnVuY3Rpb24gKF9maWVsZCwgX2VsZW1lbnQpIHsgcmV0dXJuIF90aGlzLmRlZmF1bHRDb250YWluZXI7IH0sXG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgICBfdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIgPSBfdGhpcy5vbkVsZW1lbnRJZ25vcmVkLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5maWVsZEFkZGVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRBZGRlZC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuZmllbGRSZW1vdmVkSGFuZGxlciA9IF90aGlzLm9uRmllbGRSZW1vdmVkLmJpbmQoX3RoaXMpO1xuICAgICAgICBfdGhpcy52YWxpZGF0b3JWYWxpZGF0ZWRIYW5kbGVyID0gX3RoaXMub25WYWxpZGF0b3JWYWxpZGF0ZWQuYmluZChfdGhpcyk7XG4gICAgICAgIF90aGlzLnZhbGlkYXRvck5vdFZhbGlkYXRlZEhhbmRsZXIgPSBfdGhpcy5vblZhbGlkYXRvck5vdFZhbGlkYXRlZC5iaW5kKF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGl0cyBjbGFzcyBtYXRjaGVzIHdpdGggZ2l2ZW4gcGF0dGVybi5cbiAgICAgKiBJbiBwb3B1bGFyIGNhc2VzLCBhbGwgdGhlIGZpZWxkcyBtaWdodCBmb2xsb3cgdGhlIHNhbWUgbWFya3VwLCBzbyB0aGF0IGNsb3Nlc3QgZWxlbWVudFxuICAgICAqIGNhbiBiZSB1c2VkIGFzIG1lc3NhZ2UgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIHdlIHVzZSB0aGUgQm9vdHN0cmFwIGZyYW1ld29yayB0aGVuIHRoZSBmaWVsZCBvZnRlbiBiZSBwbGFjZWQgaW5zaWRlIGFcbiAgICAgKiBgY29sLXtzaXplfS17bnVtYmVyT2ZDb2x1bW5zfWAgY2xhc3MsIHdlIGNhbiByZWdpc3RlciB0aGUgcGx1Z2luIGFzIGZvbGxvd2luZzpcbiAgICAgKiBgYGBcbiAgICAgKiAgZm9ybVZhbGlkYXRpb24oZm9ybSwge1xuICAgICAqICAgICAgcGx1Z2luczoge1xuICAgICAqICAgICAgICAgIG1lc3NhZ2U6IG5ldyBNZXNzYWdlKHtcbiAgICAgKiAgICAgICAgICAgICAgY29udGFpbmVyOiBmdW5jdGlvbihmaWVsZCwgZWxlbWVudCkge1xuICAgICAqICAgICAgICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2UuZ2V0Q2xvc2VzdENvbnRhaW5lcihlbGVtZW50LCBmb3JtLCAvXiguKikoY29sfG9mZnNldCktKHhzfHNtfG1kfGxnKS1bMC05XSsoLiopJC8pXG4gICAgICogICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICB9KVxuICAgICAqICAgICAgfVxuICAgICAqICB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGZpZWxkIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gdXBwZXIgVGhlIHVwcGVyIGVsZW1lbnQsIHNvIHdlIGRvbid0IGhhdmUgdG8gbG9vayBmb3IgdGhlIGVudGlyZSBwYWdlXG4gICAgICogQHBhcmFtIHBhdHRlcm4gVGhlIHBhdHRlcm5cbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBNZXNzYWdlLmdldENsb3Nlc3RDb250YWluZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgdXBwZXIsIHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChlbGUpIHtcbiAgICAgICAgICAgIGlmIChlbGUgPT09IHVwcGVyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGUgPSBlbGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoZWxlLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlO1xuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlRGVmYXVsdENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5jb3JlLmdldEZvcm1FbGVtZW50KCkuYXBwZW5kQ2hpbGQodGhpcy5kZWZhdWx0Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvcmVcbiAgICAgICAgICAgIC5vbignY29yZS5lbGVtZW50Lmlnbm9yZWQnLCB0aGlzLmVsZW1lbnRJZ25vcmVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vbignY29yZS5maWVsZC5hZGRlZCcsIHRoaXMuZmllbGRBZGRlZEhhbmRsZXIpXG4gICAgICAgICAgICAub24oJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vbignY29yZS52YWxpZGF0b3IudmFsaWRhdGVkJywgdGhpcy52YWxpZGF0b3JWYWxpZGF0ZWRIYW5kbGVyKVxuICAgICAgICAgICAgLm9uKCdjb3JlLnZhbGlkYXRvci5ub3R2YWxpZGF0ZWQnLCB0aGlzLnZhbGlkYXRvck5vdFZhbGlkYXRlZEhhbmRsZXIpO1xuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUudW5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51c2VEZWZhdWx0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvcmUuZ2V0Rm9ybUVsZW1lbnQoKS5yZW1vdmVDaGlsZCh0aGlzLmRlZmF1bHRDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gbWVzc2FnZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNvcmVcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUuZWxlbWVudC5pZ25vcmVkJywgdGhpcy5lbGVtZW50SWdub3JlZEhhbmRsZXIpXG4gICAgICAgICAgICAub2ZmKCdjb3JlLmZpZWxkLmFkZGVkJywgdGhpcy5maWVsZEFkZGVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUuZmllbGQucmVtb3ZlZCcsIHRoaXMuZmllbGRSZW1vdmVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUudmFsaWRhdG9yLnZhbGlkYXRlZCcsIHRoaXMudmFsaWRhdG9yVmFsaWRhdGVkSGFuZGxlcilcbiAgICAgICAgICAgIC5vZmYoJ2NvcmUudmFsaWRhdG9yLm5vdHZhbGlkYXRlZCcsIHRoaXMudmFsaWRhdG9yTm90VmFsaWRhdGVkSGFuZGxlcik7XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5vbkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAoX2VsZW1lbnQsIG1lc3NhZ2UsIF9tYXApIHtcbiAgICAgICAgICAgIGNsYXNzU2V0KG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZW5hYmxlZCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtbWVzc2FnZS1jb250YWluZXItLWRpc2FibGVkJzogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5vbkRpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKF9lbGVtZW50LCBtZXNzYWdlLCBfbWFwKSB7XG4gICAgICAgICAgICBjbGFzc1NldChtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtbWVzc2FnZS1jb250YWluZXItLWVuYWJsZWQnOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZGlzYWJsZWQnOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gUHJlcGFyZSBtZXNzYWdlIGNvbnRhaW5lciBmb3IgbmV3IGFkZGVkIGZpZWxkXG4gICAgTWVzc2FnZS5wcm90b3R5cGUub25GaWVsZEFkZGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZS5lbGVtZW50cztcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gX3RoaXMubWVzc2FnZXMuZ2V0KGVsZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBtc2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtc2cpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXNzYWdlcy5kZWxldGUoZWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZUZpZWxkQ29udGFpbmVyKGUuZmllbGQsIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gV2hlbiBhIGZpZWxkIGlzIHJlbW92ZWQsIHdlIHJlbW92ZSBhbGwgZXJyb3IgbWVzc2FnZXMgdGhhdCBhc3NvY2lhdGVzIHdpdGggdGhlIGZpZWxkXG4gICAgTWVzc2FnZS5wcm90b3R5cGUub25GaWVsZFJlbW92ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWUuZWxlbWVudHMubGVuZ3RoIHx8ICFlLmZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGUgPSBlLmVsZW1lbnRzWzBdLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSAncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgPyBbZS5lbGVtZW50c1swXV0gOiBlLmVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5tZXNzYWdlcy5oYXMoZWxlKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5tZXNzYWdlcy5nZXQoZWxlKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLm1lc3NhZ2VzLmRlbGV0ZShlbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnByZXBhcmVGaWVsZENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50c1swXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgICAgIGlmICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVFbGVtZW50Q29udGFpbmVyKGZpZWxkLCBlbGVtZW50c1swXSwgZWxlbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7IHJldHVybiBfdGhpcy5wcmVwYXJlRWxlbWVudENvbnRhaW5lcihmaWVsZCwgZWxlLCBlbGVtZW50cyk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlLnByb3RvdHlwZS5wcmVwYXJlRWxlbWVudENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaWVsZCwgZWxlbWVudCwgZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdGhpcy5vcHRzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gJyMnID09PSB0aGlzLm9wdHMuY29udGFpbmVyLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgID8gXCJbaWQ9XFxcIlwiLmNvbmNhdCh0aGlzLm9wdHMuY29udGFpbmVyLnN1YnN0cmluZygxKSwgXCJcXFwiXVwiKVxuICAgICAgICAgICAgICAgIDogdGhpcy5vcHRzLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29yZS5nZXRGb3JtRWxlbWVudCgpLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5vcHRzLmNvbnRhaW5lcihmaWVsZCwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1lc3NhZ2UpO1xuICAgICAgICBjbGFzc1NldChtZXNzYWdlLCB7XG4gICAgICAgICAgICAnZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lcic6IHRydWUsXG4gICAgICAgICAgICAnZnYtcGx1Z2lucy1tZXNzYWdlLWNvbnRhaW5lci0tZW5hYmxlZCc6IHRoaXMuaXNFbmFibGVkLFxuICAgICAgICAgICAgJ2Z2LXBsdWdpbnMtbWVzc2FnZS1jb250YWluZXItLWRpc2FibGVkJzogIXRoaXMuaXNFbmFibGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb3JlLmVtaXQoJ3BsdWdpbnMubWVzc2FnZS5wbGFjZWQnLCB7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQ6IG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnNldChlbGVtZW50LCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLmdldE1lc3NhZ2UgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVzdWx0Lm1lc3NhZ2UgPT09ICdzdHJpbmcnID8gcmVzdWx0Lm1lc3NhZ2UgOiByZXN1bHQubWVzc2FnZVt0aGlzLmNvcmUuZ2V0TG9jYWxlKCldO1xuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUub25WYWxpZGF0b3JWYWxpZGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGUuZWxlbWVudHM7XG4gICAgICAgIHZhciB0eXBlID0gZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICB2YXIgZWxlbWVudCA9ICgncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUpICYmIGVsZW1lbnRzLmxlbmd0aCA+IDAgPyBlbGVtZW50c1swXSA6IGUuZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5tZXNzYWdlcy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZUVsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZmllbGQ9XFxcIlwiLmNvbmNhdChlLmZpZWxkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSwgXCJcXFwiXVtkYXRhLXZhbGlkYXRvcj1cXFwiXCIpLmNvbmNhdChlLnZhbGlkYXRvci5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyksIFwiXFxcIl1cIikpO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlRWxlICYmICFlLnJlc3VsdC52YWxpZCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBlbGUuaW5uZXJIVE1MID0gdGhpcy5nZXRNZXNzYWdlKGUucmVzdWx0KTtcbiAgICAgICAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKCdkYXRhLWZpZWxkJywgZS5maWVsZCk7XG4gICAgICAgICAgICAgICAgZWxlLnNldEF0dHJpYnV0ZSgnZGF0YS12YWxpZGF0b3InLCBlLnZhbGlkYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jbGF6eikge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc1NldChlbGUsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgX2FbdGhpcy5vcHRzLmNsYXp6XSA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcmUuZW1pdCgncGx1Z2lucy5tZXNzYWdlLmRpc3BsYXllZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZS5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZS5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZS5yZXN1bHQubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQ6IGVsZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogZS5yZXN1bHQubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBlLnZhbGlkYXRvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VFbGUgJiYgIWUucmVzdWx0LnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRvciByZXR1cm5zIG5ldyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgbWVzc2FnZUVsZS5pbm5lckhUTUwgPSB0aGlzLmdldE1lc3NhZ2UoZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29yZS5lbWl0KCdwbHVnaW5zLm1lc3NhZ2UuZGlzcGxheWVkJywge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlLmVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBlLmZpZWxkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLnJlc3VsdC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRWxlbWVudDogbWVzc2FnZUVsZSxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogZS5yZXN1bHQubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yOiBlLnZhbGlkYXRvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2VFbGUgJiYgZS5yZXN1bHQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWVsZCBpcyB2YWxpZFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChtZXNzYWdlRWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZS5wcm90b3R5cGUub25WYWxpZGF0b3JOb3RWYWxpZGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBlLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdHlwZSA9IGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgPyBlbGVtZW50c1swXSA6IGUuZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5tZXNzYWdlcy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZUVsZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZmllbGQ9XFxcIlwiLmNvbmNhdChlLmZpZWxkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSwgXCJcXFwiXVtkYXRhLXZhbGlkYXRvcj1cXFwiXCIpLmNvbmNhdChlLnZhbGlkYXRvci5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyksIFwiXFxcIl1cIikpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VFbGUpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQobWVzc2FnZUVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLm9uRWxlbWVudElnbm9yZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBlLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdHlwZSA9IGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAncmFkaW8nID09PSB0eXBlIHx8ICdjaGVja2JveCcgPT09IHR5cGUgPyBlbGVtZW50c1swXSA6IGUuZWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyXzEgPSB0aGlzLm1lc3NhZ2VzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGNvbnRhaW5lcl8xLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1maWVsZD1cXFwiXCIuY29uY2F0KGUuZmllbGQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLCBcIlxcXCJdXCIpKSk7XG4gICAgICAgICAgICBtZXNzYWdlRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZUVsZSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcl8xLnJlbW92ZUNoaWxkKG1lc3NhZ2VFbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlO1xufShjb3JlLlBsdWdpbikpO1xuXG5leHBvcnRzLk1lc3NhZ2UgPSBNZXNzYWdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/plugin-message/lib/cjs/index.js\n");

/***/ }),

/***/ "../node_modules/@form-validation/plugin-message/lib/index.js":
/*!********************************************************************!*\
  !*** ../node_modules/@form-validation/plugin-message/lib/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/index.js */ \"../node_modules/@form-validation/plugin-message/lib/cjs/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLW1lc3NhZ2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixJQUFJLDhIQUEwQztBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tbWVzc2FnZS9saWIvaW5kZXguanM/ZDA0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvaW5kZXgubWluLmpzJyk7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvaW5kZXguanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/plugin-message/lib/index.js\n");

/***/ }),

/***/ "../node_modules/@form-validation/plugin-pure/lib/cjs/index.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@form-validation/plugin-pure/lib/cjs/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar core = __webpack_require__(/*! @form-validation/core */ \"../node_modules/@form-validation/core/lib/index.js\");\nvar pluginFramework = __webpack_require__(/*! @form-validation/plugin-framework */ \"../node_modules/@form-validation/plugin-framework/lib/index.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\nvar classSet = core.utils.classSet;\nvar Pure = /** @class */ (function (_super) {\n    __extends(Pure, _super);\n    function Pure(opts) {\n        return _super.call(this, Object.assign({}, {\n            formClass: 'fv-plugins-pure',\n            messageClass: 'fv-help-block',\n            rowInvalidClass: 'fv-has-error',\n            rowPattern: /^.*pure-control-group.*$/,\n            rowSelector: '.pure-control-group',\n            rowValidClass: 'fv-has-success',\n        }, opts)) || this;\n    }\n    Pure.prototype.onIconPlaced = function (e) {\n        var type = e.element.getAttribute('type');\n        if ('checkbox' === type || 'radio' === type) {\n            var parent_1 = e.element.parentElement;\n            classSet(e.iconElement, {\n                'fv-plugins-icon-check': true,\n            });\n            if ('LABEL' === parent_1.tagName) {\n                parent_1.parentElement.insertBefore(e.iconElement, parent_1.nextSibling);\n            }\n        }\n    };\n    return Pure;\n}(pluginFramework.Framework));\n\nexports.Pure = Pure;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLXB1cmUvbGliL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsaUZBQXVCO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHlHQUFtQzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tcHVyZS9saWIvY2pzL2luZGV4LmpzPzNkYjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0Bmb3JtLXZhbGlkYXRpb24vY29yZScpO1xudmFyIHBsdWdpbkZyYW1ld29yayA9IHJlcXVpcmUoJ0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLWZyYW1ld29yaycpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cblxuLyoqXG4gKiBGb3JtVmFsaWRhdGlvbiAoaHR0cHM6Ly9mb3JtdmFsaWRhdGlvbi5pbylcbiAqIFRoZSBiZXN0IHZhbGlkYXRpb24gbGlicmFyeSBmb3IgSmF2YVNjcmlwdFxuICogKGMpIDIwMTMgLSAyMDIzIE5ndXllbiBIdXUgUGh1b2MgPG1lQHBodW9jLm5nPlxuICovXG52YXIgY2xhc3NTZXQgPSBjb3JlLnV0aWxzLmNsYXNzU2V0O1xudmFyIFB1cmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFB1cmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHVyZShvcHRzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICBmb3JtQ2xhc3M6ICdmdi1wbHVnaW5zLXB1cmUnLFxuICAgICAgICAgICAgbWVzc2FnZUNsYXNzOiAnZnYtaGVscC1ibG9jaycsXG4gICAgICAgICAgICByb3dJbnZhbGlkQ2xhc3M6ICdmdi1oYXMtZXJyb3InLFxuICAgICAgICAgICAgcm93UGF0dGVybjogL14uKnB1cmUtY29udHJvbC1ncm91cC4qJC8sXG4gICAgICAgICAgICByb3dTZWxlY3RvcjogJy5wdXJlLWNvbnRyb2wtZ3JvdXAnLFxuICAgICAgICAgICAgcm93VmFsaWRDbGFzczogJ2Z2LWhhcy1zdWNjZXNzJyxcbiAgICAgICAgfSwgb3B0cykpIHx8IHRoaXM7XG4gICAgfVxuICAgIFB1cmUucHJvdG90eXBlLm9uSWNvblBsYWNlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICBpZiAoJ2NoZWNrYm94JyA9PT0gdHlwZSB8fCAncmFkaW8nID09PSB0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBlLmVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGNsYXNzU2V0KGUuaWNvbkVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAnZnYtcGx1Z2lucy1pY29uLWNoZWNrJzogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCdMQUJFTCcgPT09IHBhcmVudF8xLnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRfMS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShlLmljb25FbGVtZW50LCBwYXJlbnRfMS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQdXJlO1xufShwbHVnaW5GcmFtZXdvcmsuRnJhbWV3b3JrKSk7XG5cbmV4cG9ydHMuUHVyZSA9IFB1cmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/plugin-pure/lib/cjs/index.js\n");

/***/ }),

/***/ "../node_modules/@form-validation/plugin-pure/lib/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/@form-validation/plugin-pure/lib/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * FormValidation (https://formvalidation.io)\n * The best validation library for JavaScript\n * (c) 2013 - 2023 Nguyen Huu Phuoc <me@phuoc.ng>\n */\n\n\n\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/index.js */ \"../node_modules/@form-validation/plugin-pure/lib/cjs/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bmb3JtLXZhbGlkYXRpb24vcGx1Z2luLXB1cmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixJQUFJLDJIQUEwQztBQUM5QyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGZvcm0tdmFsaWRhdGlvbi9wbHVnaW4tcHVyZS9saWIvaW5kZXguanM/NjNjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZvcm1WYWxpZGF0aW9uIChodHRwczovL2Zvcm12YWxpZGF0aW9uLmlvKVxuICogVGhlIGJlc3QgdmFsaWRhdGlvbiBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0XG4gKiAoYykgMjAxMyAtIDIwMjMgTmd1eWVuIEh1dSBQaHVvYyA8bWVAcGh1b2Mubmc+XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvaW5kZXgubWluLmpzJyk7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvaW5kZXguanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@form-validation/plugin-pure/lib/index.js\n");

/***/ }),

/***/ "../node_modules/validate.js/validate.js":
/*!***********************************************!*\
  !*** ../node_modules/validate.js/validate.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/*!\n * validate.js 0.13.1\n *\n * (c) 2013-2019 Nicklas Ansman, 2013 Wrapp\n * Validate.js may be freely distributed under the MIT license.\n * For all details and documentation:\n * http://validatejs.org/\n */\n\n(function(exports, module, define) {\n  \"use strict\";\n\n  // The main function that calls the validators specified by the constraints.\n  // The options are the following:\n  //   - format (string) - An option that controls how the returned value is formatted\n  //     * flat - Returns a flat array of just the error messages\n  //     * grouped - Returns the messages grouped by attribute (default)\n  //     * detailed - Returns an array of the raw validation data\n  //   - fullMessages (boolean) - If `true` (default) the attribute name is prepended to the error.\n  //\n  // Please note that the options are also passed to each validator.\n  var validate = function(attributes, constraints, options) {\n    options = v.extend({}, v.options, options);\n\n    var results = v.runValidations(attributes, constraints, options)\n      , attr\n      , validator;\n\n    if (results.some(function(r) { return v.isPromise(r.error); })) {\n      throw new Error(\"Use validate.async if you want support for promises\");\n    }\n    return validate.processValidationResults(results, options);\n  };\n\n  var v = validate;\n\n  // Copies over attributes from one or more sources to a single destination.\n  // Very much similar to underscore's extend.\n  // The first argument is the target object and the remaining arguments will be\n  // used as sources.\n  v.extend = function(obj) {\n    [].slice.call(arguments, 1).forEach(function(source) {\n      for (var attr in source) {\n        obj[attr] = source[attr];\n      }\n    });\n    return obj;\n  };\n\n  v.extend(validate, {\n    // This is the version of the library as a semver.\n    // The toString function will allow it to be coerced into a string\n    version: {\n      major: 0,\n      minor: 13,\n      patch: 1,\n      metadata: null,\n      toString: function() {\n        var version = v.format(\"%{major}.%{minor}.%{patch}\", v.version);\n        if (!v.isEmpty(v.version.metadata)) {\n          version += \"+\" + v.version.metadata;\n        }\n        return version;\n      }\n    },\n\n    // Below is the dependencies that are used in validate.js\n\n    // The constructor of the Promise implementation.\n    // If you are using Q.js, RSVP or any other A+ compatible implementation\n    // override this attribute to be the constructor of that promise.\n    // Since jQuery promises aren't A+ compatible they won't work.\n    Promise: typeof Promise !== \"undefined\" ? Promise : /* istanbul ignore next */ null,\n\n    EMPTY_STRING_REGEXP: /^\\s*$/,\n\n    // Runs the validators specified by the constraints object.\n    // Will return an array of the format:\n    //     [{attribute: \"<attribute name>\", error: \"<validation result>\"}, ...]\n    runValidations: function(attributes, constraints, options) {\n      var results = []\n        , attr\n        , validatorName\n        , value\n        , validators\n        , validator\n        , validatorOptions\n        , error;\n\n      if (v.isDomElement(attributes) || v.isJqueryElement(attributes)) {\n        attributes = v.collectFormValues(attributes);\n      }\n\n      // Loops through each constraints, finds the correct validator and run it.\n      for (attr in constraints) {\n        value = v.getDeepObjectValue(attributes, attr);\n        // This allows the constraints for an attribute to be a function.\n        // The function will be called with the value, attribute name, the complete dict of\n        // attributes as well as the options and constraints passed in.\n        // This is useful when you want to have different\n        // validations depending on the attribute value.\n        validators = v.result(constraints[attr], value, attributes, attr, options, constraints);\n\n        for (validatorName in validators) {\n          validator = v.validators[validatorName];\n\n          if (!validator) {\n            error = v.format(\"Unknown validator %{name}\", {name: validatorName});\n            throw new Error(error);\n          }\n\n          validatorOptions = validators[validatorName];\n          // This allows the options to be a function. The function will be\n          // called with the value, attribute name, the complete dict of\n          // attributes as well as the options and constraints passed in.\n          // This is useful when you want to have different\n          // validations depending on the attribute value.\n          validatorOptions = v.result(validatorOptions, value, attributes, attr, options, constraints);\n          if (!validatorOptions) {\n            continue;\n          }\n          results.push({\n            attribute: attr,\n            value: value,\n            validator: validatorName,\n            globalOptions: options,\n            attributes: attributes,\n            options: validatorOptions,\n            error: validator.call(validator,\n                value,\n                validatorOptions,\n                attr,\n                attributes,\n                options)\n          });\n        }\n      }\n\n      return results;\n    },\n\n    // Takes the output from runValidations and converts it to the correct\n    // output format.\n    processValidationResults: function(errors, options) {\n      errors = v.pruneEmptyErrors(errors, options);\n      errors = v.expandMultipleErrors(errors, options);\n      errors = v.convertErrorMessages(errors, options);\n\n      var format = options.format || \"grouped\";\n\n      if (typeof v.formatters[format] === 'function') {\n        errors = v.formatters[format](errors);\n      } else {\n        throw new Error(v.format(\"Unknown format %{format}\", options));\n      }\n\n      return v.isEmpty(errors) ? undefined : errors;\n    },\n\n    // Runs the validations with support for promises.\n    // This function will return a promise that is settled when all the\n    // validation promises have been completed.\n    // It can be called even if no validations returned a promise.\n    async: function(attributes, constraints, options) {\n      options = v.extend({}, v.async.options, options);\n\n      var WrapErrors = options.wrapErrors || function(errors) {\n        return errors;\n      };\n\n      // Removes unknown attributes\n      if (options.cleanAttributes !== false) {\n        attributes = v.cleanAttributes(attributes, constraints);\n      }\n\n      var results = v.runValidations(attributes, constraints, options);\n\n      return new v.Promise(function(resolve, reject) {\n        v.waitForResults(results).then(function() {\n          var errors = v.processValidationResults(results, options);\n          if (errors) {\n            reject(new WrapErrors(errors, options, attributes, constraints));\n          } else {\n            resolve(attributes);\n          }\n        }, function(err) {\n          reject(err);\n        });\n      });\n    },\n\n    single: function(value, constraints, options) {\n      options = v.extend({}, v.single.options, options, {\n        format: \"flat\",\n        fullMessages: false\n      });\n      return v({single: value}, {single: constraints}, options);\n    },\n\n    // Returns a promise that is resolved when all promises in the results array\n    // are settled. The promise returned from this function is always resolved,\n    // never rejected.\n    // This function modifies the input argument, it replaces the promises\n    // with the value returned from the promise.\n    waitForResults: function(results) {\n      // Create a sequence of all the results starting with a resolved promise.\n      return results.reduce(function(memo, result) {\n        // If this result isn't a promise skip it in the sequence.\n        if (!v.isPromise(result.error)) {\n          return memo;\n        }\n\n        return memo.then(function() {\n          return result.error.then(function(error) {\n            result.error = error || null;\n          });\n        });\n      }, new v.Promise(function(r) { r(); })); // A resolved promise\n    },\n\n    // If the given argument is a call: function the and: function return the value\n    // otherwise just return the value. Additional arguments will be passed as\n    // arguments to the function.\n    // Example:\n    // ```\n    // result('foo') // 'foo'\n    // result(Math.max, 1, 2) // 2\n    // ```\n    result: function(value) {\n      var args = [].slice.call(arguments, 1);\n      if (typeof value === 'function') {\n        value = value.apply(null, args);\n      }\n      return value;\n    },\n\n    // Checks if the value is a number. This function does not consider NaN a\n    // number like many other `isNumber` functions do.\n    isNumber: function(value) {\n      return typeof value === 'number' && !isNaN(value);\n    },\n\n    // Returns false if the object is not a function\n    isFunction: function(value) {\n      return typeof value === 'function';\n    },\n\n    // A simple check to verify that the value is an integer. Uses `isNumber`\n    // and a simple modulo check.\n    isInteger: function(value) {\n      return v.isNumber(value) && value % 1 === 0;\n    },\n\n    // Checks if the value is a boolean\n    isBoolean: function(value) {\n      return typeof value === 'boolean';\n    },\n\n    // Uses the `Object` function to check if the given argument is an object.\n    isObject: function(obj) {\n      return obj === Object(obj);\n    },\n\n    // Simply checks if the object is an instance of a date\n    isDate: function(obj) {\n      return obj instanceof Date;\n    },\n\n    // Returns false if the object is `null` of `undefined`\n    isDefined: function(obj) {\n      return obj !== null && obj !== undefined;\n    },\n\n    // Checks if the given argument is a promise. Anything with a `then`\n    // function is considered a promise.\n    isPromise: function(p) {\n      return !!p && v.isFunction(p.then);\n    },\n\n    isJqueryElement: function(o) {\n      return o && v.isString(o.jquery);\n    },\n\n    isDomElement: function(o) {\n      if (!o) {\n        return false;\n      }\n\n      if (!o.querySelectorAll || !o.querySelector) {\n        return false;\n      }\n\n      if (v.isObject(document) && o === document) {\n        return true;\n      }\n\n      // http://stackoverflow.com/a/384380/699304\n      /* istanbul ignore else */\n      if (typeof HTMLElement === \"object\") {\n        return o instanceof HTMLElement;\n      } else {\n        return o &&\n          typeof o === \"object\" &&\n          o !== null &&\n          o.nodeType === 1 &&\n          typeof o.nodeName === \"string\";\n      }\n    },\n\n    isEmpty: function(value) {\n      var attr;\n\n      // Null and undefined are empty\n      if (!v.isDefined(value)) {\n        return true;\n      }\n\n      // functions are non empty\n      if (v.isFunction(value)) {\n        return false;\n      }\n\n      // Whitespace only strings are empty\n      if (v.isString(value)) {\n        return v.EMPTY_STRING_REGEXP.test(value);\n      }\n\n      // For arrays we use the length property\n      if (v.isArray(value)) {\n        return value.length === 0;\n      }\n\n      // Dates have no attributes but aren't empty\n      if (v.isDate(value)) {\n        return false;\n      }\n\n      // If we find at least one property we consider it non empty\n      if (v.isObject(value)) {\n        for (attr in value) {\n          return false;\n        }\n        return true;\n      }\n\n      return false;\n    },\n\n    // Formats the specified strings with the given values like so:\n    // ```\n    // format(\"Foo: %{foo}\", {foo: \"bar\"}) // \"Foo bar\"\n    // ```\n    // If you want to write %{...} without having it replaced simply\n    // prefix it with % like this `Foo: %%{foo}` and it will be returned\n    // as `\"Foo: %{foo}\"`\n    format: v.extend(function(str, vals) {\n      if (!v.isString(str)) {\n        return str;\n      }\n      return str.replace(v.format.FORMAT_REGEXP, function(m0, m1, m2) {\n        if (m1 === '%') {\n          return \"%{\" + m2 + \"}\";\n        } else {\n          return String(vals[m2]);\n        }\n      });\n    }, {\n      // Finds %{key} style patterns in the given string\n      FORMAT_REGEXP: /(%?)%\\{([^\\}]+)\\}/g\n    }),\n\n    // \"Prettifies\" the given string.\n    // Prettifying means replacing [.\\_-] with spaces as well as splitting\n    // camel case words.\n    prettify: function(str) {\n      if (v.isNumber(str)) {\n        // If there are more than 2 decimals round it to two\n        if ((str * 100) % 1 === 0) {\n          return \"\" + str;\n        } else {\n          return parseFloat(Math.round(str * 100) / 100).toFixed(2);\n        }\n      }\n\n      if (v.isArray(str)) {\n        return str.map(function(s) { return v.prettify(s); }).join(\", \");\n      }\n\n      if (v.isObject(str)) {\n        if (!v.isDefined(str.toString)) {\n          return JSON.stringify(str);\n        }\n\n        return str.toString();\n      }\n\n      // Ensure the string is actually a string\n      str = \"\" + str;\n\n      return str\n        // Splits keys separated by periods\n        .replace(/([^\\s])\\.([^\\s])/g, '$1 $2')\n        // Removes backslashes\n        .replace(/\\\\+/g, '')\n        // Replaces - and - with space\n        .replace(/[_-]/g, ' ')\n        // Splits camel cased words\n        .replace(/([a-z])([A-Z])/g, function(m0, m1, m2) {\n          return \"\" + m1 + \" \" + m2.toLowerCase();\n        })\n        .toLowerCase();\n    },\n\n    stringifyValue: function(value, options) {\n      var prettify = options && options.prettify || v.prettify;\n      return prettify(value);\n    },\n\n    isString: function(value) {\n      return typeof value === 'string';\n    },\n\n    isArray: function(value) {\n      return {}.toString.call(value) === '[object Array]';\n    },\n\n    // Checks if the object is a hash, which is equivalent to an object that\n    // is neither an array nor a function.\n    isHash: function(value) {\n      return v.isObject(value) && !v.isArray(value) && !v.isFunction(value);\n    },\n\n    contains: function(obj, value) {\n      if (!v.isDefined(obj)) {\n        return false;\n      }\n      if (v.isArray(obj)) {\n        return obj.indexOf(value) !== -1;\n      }\n      return value in obj;\n    },\n\n    unique: function(array) {\n      if (!v.isArray(array)) {\n        return array;\n      }\n      return array.filter(function(el, index, array) {\n        return array.indexOf(el) == index;\n      });\n    },\n\n    forEachKeyInKeypath: function(object, keypath, callback) {\n      if (!v.isString(keypath)) {\n        return undefined;\n      }\n\n      var key = \"\"\n        , i\n        , escape = false;\n\n      for (i = 0; i < keypath.length; ++i) {\n        switch (keypath[i]) {\n          case '.':\n            if (escape) {\n              escape = false;\n              key += '.';\n            } else {\n              object = callback(object, key, false);\n              key = \"\";\n            }\n            break;\n\n          case '\\\\':\n            if (escape) {\n              escape = false;\n              key += '\\\\';\n            } else {\n              escape = true;\n            }\n            break;\n\n          default:\n            escape = false;\n            key += keypath[i];\n            break;\n        }\n      }\n\n      return callback(object, key, true);\n    },\n\n    getDeepObjectValue: function(obj, keypath) {\n      if (!v.isObject(obj)) {\n        return undefined;\n      }\n\n      return v.forEachKeyInKeypath(obj, keypath, function(obj, key) {\n        if (v.isObject(obj)) {\n          return obj[key];\n        }\n      });\n    },\n\n    // This returns an object with all the values of the form.\n    // It uses the input name as key and the value as value\n    // So for example this:\n    // <input type=\"text\" name=\"email\" value=\"foo@bar.com\" />\n    // would return:\n    // {email: \"foo@bar.com\"}\n    collectFormValues: function(form, options) {\n      var values = {}\n        , i\n        , j\n        , input\n        , inputs\n        , option\n        , value;\n\n      if (v.isJqueryElement(form)) {\n        form = form[0];\n      }\n\n      if (!form) {\n        return values;\n      }\n\n      options = options || {};\n\n      inputs = form.querySelectorAll(\"input[name], textarea[name]\");\n      for (i = 0; i < inputs.length; ++i) {\n        input = inputs.item(i);\n\n        if (v.isDefined(input.getAttribute(\"data-ignored\"))) {\n          continue;\n        }\n\n        var name = input.name.replace(/\\./g, \"\\\\\\\\.\");\n        value = v.sanitizeFormValue(input.value, options);\n        if (input.type === \"number\") {\n          value = value ? +value : null;\n        } else if (input.type === \"checkbox\") {\n          if (input.attributes.value) {\n            if (!input.checked) {\n              value = values[name] || null;\n            }\n          } else {\n            value = input.checked;\n          }\n        } else if (input.type === \"radio\") {\n          if (!input.checked) {\n            value = values[name] || null;\n          }\n        }\n        values[name] = value;\n      }\n\n      inputs = form.querySelectorAll(\"select[name]\");\n      for (i = 0; i < inputs.length; ++i) {\n        input = inputs.item(i);\n        if (v.isDefined(input.getAttribute(\"data-ignored\"))) {\n          continue;\n        }\n\n        if (input.multiple) {\n          value = [];\n          for (j in input.options) {\n            option = input.options[j];\n             if (option && option.selected) {\n              value.push(v.sanitizeFormValue(option.value, options));\n            }\n          }\n        } else {\n          var _val = typeof input.options[input.selectedIndex] !== 'undefined' ? input.options[input.selectedIndex].value : /* istanbul ignore next */ '';\n          value = v.sanitizeFormValue(_val, options);\n        }\n        values[input.name] = value;\n      }\n\n      return values;\n    },\n\n    sanitizeFormValue: function(value, options) {\n      if (options.trim && v.isString(value)) {\n        value = value.trim();\n      }\n\n      if (options.nullify !== false && value === \"\") {\n        return null;\n      }\n      return value;\n    },\n\n    capitalize: function(str) {\n      if (!v.isString(str)) {\n        return str;\n      }\n      return str[0].toUpperCase() + str.slice(1);\n    },\n\n    // Remove all errors who's error attribute is empty (null or undefined)\n    pruneEmptyErrors: function(errors) {\n      return errors.filter(function(error) {\n        return !v.isEmpty(error.error);\n      });\n    },\n\n    // In\n    // [{error: [\"err1\", \"err2\"], ...}]\n    // Out\n    // [{error: \"err1\", ...}, {error: \"err2\", ...}]\n    //\n    // All attributes in an error with multiple messages are duplicated\n    // when expanding the errors.\n    expandMultipleErrors: function(errors) {\n      var ret = [];\n      errors.forEach(function(error) {\n        // Removes errors without a message\n        if (v.isArray(error.error)) {\n          error.error.forEach(function(msg) {\n            ret.push(v.extend({}, error, {error: msg}));\n          });\n        } else {\n          ret.push(error);\n        }\n      });\n      return ret;\n    },\n\n    // Converts the error mesages by prepending the attribute name unless the\n    // message is prefixed by ^\n    convertErrorMessages: function(errors, options) {\n      options = options || {};\n\n      var ret = []\n        , prettify = options.prettify || v.prettify;\n      errors.forEach(function(errorInfo) {\n        var error = v.result(errorInfo.error,\n            errorInfo.value,\n            errorInfo.attribute,\n            errorInfo.options,\n            errorInfo.attributes,\n            errorInfo.globalOptions);\n\n        if (!v.isString(error)) {\n          ret.push(errorInfo);\n          return;\n        }\n\n        if (error[0] === '^') {\n          error = error.slice(1);\n        } else if (options.fullMessages !== false) {\n          error = v.capitalize(prettify(errorInfo.attribute)) + \" \" + error;\n        }\n        error = error.replace(/\\\\\\^/g, \"^\");\n        error = v.format(error, {\n          value: v.stringifyValue(errorInfo.value, options)\n        });\n        ret.push(v.extend({}, errorInfo, {error: error}));\n      });\n      return ret;\n    },\n\n    // In:\n    // [{attribute: \"<attributeName>\", ...}]\n    // Out:\n    // {\"<attributeName>\": [{attribute: \"<attributeName>\", ...}]}\n    groupErrorsByAttribute: function(errors) {\n      var ret = {};\n      errors.forEach(function(error) {\n        var list = ret[error.attribute];\n        if (list) {\n          list.push(error);\n        } else {\n          ret[error.attribute] = [error];\n        }\n      });\n      return ret;\n    },\n\n    // In:\n    // [{error: \"<message 1>\", ...}, {error: \"<message 2>\", ...}]\n    // Out:\n    // [\"<message 1>\", \"<message 2>\"]\n    flattenErrorsToArray: function(errors) {\n      return errors\n        .map(function(error) { return error.error; })\n        .filter(function(value, index, self) {\n          return self.indexOf(value) === index;\n        });\n    },\n\n    cleanAttributes: function(attributes, whitelist) {\n      function whitelistCreator(obj, key, last) {\n        if (v.isObject(obj[key])) {\n          return obj[key];\n        }\n        return (obj[key] = last ? true : {});\n      }\n\n      function buildObjectWhitelist(whitelist) {\n        var ow = {}\n          , lastObject\n          , attr;\n        for (attr in whitelist) {\n          if (!whitelist[attr]) {\n            continue;\n          }\n          v.forEachKeyInKeypath(ow, attr, whitelistCreator);\n        }\n        return ow;\n      }\n\n      function cleanRecursive(attributes, whitelist) {\n        if (!v.isObject(attributes)) {\n          return attributes;\n        }\n\n        var ret = v.extend({}, attributes)\n          , w\n          , attribute;\n\n        for (attribute in attributes) {\n          w = whitelist[attribute];\n\n          if (v.isObject(w)) {\n            ret[attribute] = cleanRecursive(ret[attribute], w);\n          } else if (!w) {\n            delete ret[attribute];\n          }\n        }\n        return ret;\n      }\n\n      if (!v.isObject(whitelist) || !v.isObject(attributes)) {\n        return {};\n      }\n\n      whitelist = buildObjectWhitelist(whitelist);\n      return cleanRecursive(attributes, whitelist);\n    },\n\n    exposeModule: function(validate, root, exports, module, define) {\n      if (exports) {\n        if (module && module.exports) {\n          exports = module.exports = validate;\n        }\n        exports.validate = validate;\n      } else {\n        root.validate = validate;\n        if (validate.isFunction(define) && define.amd) {\n          define([], function () { return validate; });\n        }\n      }\n    },\n\n    warn: function(msg) {\n      if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(\"[validate.js] \" + msg);\n      }\n    },\n\n    error: function(msg) {\n      if (typeof console !== \"undefined\" && console.error) {\n        console.error(\"[validate.js] \" + msg);\n      }\n    }\n  });\n\n  validate.validators = {\n    // Presence validates that the value isn't empty\n    presence: function(value, options) {\n      options = v.extend({}, this.options, options);\n      if (options.allowEmpty !== false ? !v.isDefined(value) : v.isEmpty(value)) {\n        return options.message || this.message || \"can't be blank\";\n      }\n    },\n    length: function(value, options, attribute) {\n      // Empty values are allowed\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var is = options.is\n        , maximum = options.maximum\n        , minimum = options.minimum\n        , tokenizer = options.tokenizer || function(val) { return val; }\n        , err\n        , errors = [];\n\n      value = tokenizer(value);\n      var length = value.length;\n      if(!v.isNumber(length)) {\n        return options.message || this.notValid || \"has an incorrect length\";\n      }\n\n      // Is checks\n      if (v.isNumber(is) && length !== is) {\n        err = options.wrongLength ||\n          this.wrongLength ||\n          \"is the wrong length (should be %{count} characters)\";\n        errors.push(v.format(err, {count: is}));\n      }\n\n      if (v.isNumber(minimum) && length < minimum) {\n        err = options.tooShort ||\n          this.tooShort ||\n          \"is too short (minimum is %{count} characters)\";\n        errors.push(v.format(err, {count: minimum}));\n      }\n\n      if (v.isNumber(maximum) && length > maximum) {\n        err = options.tooLong ||\n          this.tooLong ||\n          \"is too long (maximum is %{count} characters)\";\n        errors.push(v.format(err, {count: maximum}));\n      }\n\n      if (errors.length > 0) {\n        return options.message || errors;\n      }\n    },\n    numericality: function(value, options, attribute, attributes, globalOptions) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var errors = []\n        , name\n        , count\n        , checks = {\n            greaterThan:          function(v, c) { return v > c; },\n            greaterThanOrEqualTo: function(v, c) { return v >= c; },\n            equalTo:              function(v, c) { return v === c; },\n            lessThan:             function(v, c) { return v < c; },\n            lessThanOrEqualTo:    function(v, c) { return v <= c; },\n            divisibleBy:          function(v, c) { return v % c === 0; }\n          }\n        , prettify = options.prettify ||\n          (globalOptions && globalOptions.prettify) ||\n          v.prettify;\n\n      // Strict will check that it is a valid looking number\n      if (v.isString(value) && options.strict) {\n        var pattern = \"^-?(0|[1-9]\\\\d*)\";\n        if (!options.onlyInteger) {\n          pattern += \"(\\\\.\\\\d+)?\";\n        }\n        pattern += \"$\";\n\n        if (!(new RegExp(pattern).test(value))) {\n          return options.message ||\n            options.notValid ||\n            this.notValid ||\n            this.message ||\n            \"must be a valid number\";\n        }\n      }\n\n      // Coerce the value to a number unless we're being strict.\n      if (options.noStrings !== true && v.isString(value) && !v.isEmpty(value)) {\n        value = +value;\n      }\n\n      // If it's not a number we shouldn't continue since it will compare it.\n      if (!v.isNumber(value)) {\n        return options.message ||\n          options.notValid ||\n          this.notValid ||\n          this.message ||\n          \"is not a number\";\n      }\n\n      // Same logic as above, sort of. Don't bother with comparisons if this\n      // doesn't pass.\n      if (options.onlyInteger && !v.isInteger(value)) {\n        return options.message ||\n          options.notInteger ||\n          this.notInteger ||\n          this.message ||\n          \"must be an integer\";\n      }\n\n      for (name in checks) {\n        count = options[name];\n        if (v.isNumber(count) && !checks[name](value, count)) {\n          // This picks the default message if specified\n          // For example the greaterThan check uses the message from\n          // this.notGreaterThan so we capitalize the name and prepend \"not\"\n          var key = \"not\" + v.capitalize(name);\n          var msg = options[key] ||\n            this[key] ||\n            this.message ||\n            \"must be %{type} %{count}\";\n\n          errors.push(v.format(msg, {\n            count: count,\n            type: prettify(name)\n          }));\n        }\n      }\n\n      if (options.odd && value % 2 !== 1) {\n        errors.push(options.notOdd ||\n            this.notOdd ||\n            this.message ||\n            \"must be odd\");\n      }\n      if (options.even && value % 2 !== 0) {\n        errors.push(options.notEven ||\n            this.notEven ||\n            this.message ||\n            \"must be even\");\n      }\n\n      if (errors.length) {\n        return options.message || errors;\n      }\n    },\n    datetime: v.extend(function(value, options) {\n      if (!v.isFunction(this.parse) || !v.isFunction(this.format)) {\n        throw new Error(\"Both the parse and format functions needs to be set to use the datetime/date validator\");\n      }\n\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var err\n        , errors = []\n        , earliest = options.earliest ? this.parse(options.earliest, options) : NaN\n        , latest = options.latest ? this.parse(options.latest, options) : NaN;\n\n      value = this.parse(value, options);\n\n      // 86400000 is the number of milliseconds in a day, this is used to remove\n      // the time from the date\n      if (isNaN(value) || options.dateOnly && value % 86400000 !== 0) {\n        err = options.notValid ||\n          options.message ||\n          this.notValid ||\n          \"must be a valid date\";\n        return v.format(err, {value: arguments[0]});\n      }\n\n      if (!isNaN(earliest) && value < earliest) {\n        err = options.tooEarly ||\n          options.message ||\n          this.tooEarly ||\n          \"must be no earlier than %{date}\";\n        err = v.format(err, {\n          value: this.format(value, options),\n          date: this.format(earliest, options)\n        });\n        errors.push(err);\n      }\n\n      if (!isNaN(latest) && value > latest) {\n        err = options.tooLate ||\n          options.message ||\n          this.tooLate ||\n          \"must be no later than %{date}\";\n        err = v.format(err, {\n          date: this.format(latest, options),\n          value: this.format(value, options)\n        });\n        errors.push(err);\n      }\n\n      if (errors.length) {\n        return v.unique(errors);\n      }\n    }, {\n      parse: null,\n      format: null\n    }),\n    date: function(value, options) {\n      options = v.extend({}, options, {dateOnly: true});\n      return v.validators.datetime.call(v.validators.datetime, value, options);\n    },\n    format: function(value, options) {\n      if (v.isString(options) || (options instanceof RegExp)) {\n        options = {pattern: options};\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var message = options.message || this.message || \"is invalid\"\n        , pattern = options.pattern\n        , match;\n\n      // Empty values are allowed\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (!v.isString(value)) {\n        return message;\n      }\n\n      if (v.isString(pattern)) {\n        pattern = new RegExp(options.pattern, options.flags);\n      }\n      match = pattern.exec(value);\n      if (!match || match[0].length != value.length) {\n        return message;\n      }\n    },\n    inclusion: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (v.isArray(options)) {\n        options = {within: options};\n      }\n      options = v.extend({}, this.options, options);\n      if (v.contains(options.within, value)) {\n        return;\n      }\n      var message = options.message ||\n        this.message ||\n        \"^%{value} is not included in the list\";\n      return v.format(message, {value: value});\n    },\n    exclusion: function(value, options) {\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (v.isArray(options)) {\n        options = {within: options};\n      }\n      options = v.extend({}, this.options, options);\n      if (!v.contains(options.within, value)) {\n        return;\n      }\n      var message = options.message || this.message || \"^%{value} is restricted\";\n      if (v.isString(options.within[value])) {\n        value = options.within[value];\n      }\n      return v.format(message, {value: value});\n    },\n    email: v.extend(function(value, options) {\n      options = v.extend({}, this.options, options);\n      var message = options.message || this.message || \"is not a valid email\";\n      // Empty values are fine\n      if (!v.isDefined(value)) {\n        return;\n      }\n      if (!v.isString(value)) {\n        return message;\n      }\n      if (!this.PATTERN.exec(value)) {\n        return message;\n      }\n    }, {\n      PATTERN: /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i\n    }),\n    equality: function(value, options, attribute, attributes, globalOptions) {\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      if (v.isString(options)) {\n        options = {attribute: options};\n      }\n      options = v.extend({}, this.options, options);\n      var message = options.message ||\n        this.message ||\n        \"is not equal to %{attribute}\";\n\n      if (v.isEmpty(options.attribute) || !v.isString(options.attribute)) {\n        throw new Error(\"The attribute must be a non empty string\");\n      }\n\n      var otherValue = v.getDeepObjectValue(attributes, options.attribute)\n        , comparator = options.comparator || function(v1, v2) {\n          return v1 === v2;\n        }\n        , prettify = options.prettify ||\n          (globalOptions && globalOptions.prettify) ||\n          v.prettify;\n\n      if (!comparator(value, otherValue, options, attribute, attributes)) {\n        return v.format(message, {attribute: prettify(options.attribute)});\n      }\n    },\n    // A URL validator that is used to validate URLs with the ability to\n    // restrict schemes and some domains.\n    url: function(value, options) {\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      options = v.extend({}, this.options, options);\n\n      var message = options.message || this.message || \"is not a valid url\"\n        , schemes = options.schemes || this.schemes || ['http', 'https']\n        , allowLocal = options.allowLocal || this.allowLocal || false\n        , allowDataUrl = options.allowDataUrl || this.allowDataUrl || false;\n      if (!v.isString(value)) {\n        return message;\n      }\n\n      // https://gist.github.com/dperini/729294\n      var regex =\n        \"^\" +\n        // protocol identifier\n        \"(?:(?:\" + schemes.join(\"|\") + \")://)\" +\n        // user:pass authentication\n        \"(?:\\\\S+(?::\\\\S*)?@)?\" +\n        \"(?:\";\n\n      var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n\n      if (allowLocal) {\n        tld += \"?\";\n      } else {\n        regex +=\n          // IP address exclusion\n          // private & local networks\n          \"(?!(?:10|127)(?:\\\\.\\\\d{1,3}){3})\" +\n          \"(?!(?:169\\\\.254|192\\\\.168)(?:\\\\.\\\\d{1,3}){2})\" +\n          \"(?!172\\\\.(?:1[6-9]|2\\\\d|3[0-1])(?:\\\\.\\\\d{1,3}){2})\";\n      }\n\n      regex +=\n          // IP address dotted notation octets\n          // excludes loopback network 0.0.0.0\n          // excludes reserved space >= 224.0.0.0\n          // excludes network & broacast addresses\n          // (first & last IP address of each class)\n          \"(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])\" +\n          \"(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}\" +\n          \"(?:\\\\.(?:[1-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))\" +\n        \"|\" +\n          // host name\n          \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\" +\n          // domain name\n          \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\" +\n          tld +\n        \")\" +\n        // port number\n        \"(?::\\\\d{2,5})?\" +\n        // resource path\n        \"(?:[/?#]\\\\S*)?\" +\n      \"$\";\n\n      if (allowDataUrl) {\n        // RFC 2397\n        var mediaType = \"\\\\w+\\\\/[-+.\\\\w]+(?:;[\\\\w=]+)*\";\n        var urlchar = \"[A-Za-z0-9-_.!~\\\\*'();\\\\/?:@&=+$,%]*\";\n        var dataurl = \"data:(?:\"+mediaType+\")?(?:;base64)?,\"+urlchar;\n        regex = \"(?:\"+regex+\")|(?:^\"+dataurl+\"$)\";\n      }\n\n      var PATTERN = new RegExp(regex, 'i');\n      if (!PATTERN.exec(value)) {\n        return message;\n      }\n    },\n    type: v.extend(function(value, originalOptions, attribute, attributes, globalOptions) {\n      if (v.isString(originalOptions)) {\n        originalOptions = {type: originalOptions};\n      }\n\n      if (!v.isDefined(value)) {\n        return;\n      }\n\n      var options = v.extend({}, this.options, originalOptions);\n\n      var type = options.type;\n      if (!v.isDefined(type)) {\n        throw new Error(\"No type was specified\");\n      }\n\n      var check;\n      if (v.isFunction(type)) {\n        check = type;\n      } else {\n        check = this.types[type];\n      }\n\n      if (!v.isFunction(check)) {\n        throw new Error(\"validate.validators.type.types.\" + type + \" must be a function.\");\n      }\n\n      if (!check(value, options, attribute, attributes, globalOptions)) {\n        var message = originalOptions.message ||\n          this.messages[type] ||\n          this.message ||\n          options.message ||\n          (v.isFunction(type) ? \"must be of the correct type\" : \"must be of type %{type}\");\n\n        if (v.isFunction(message)) {\n          message = message(value, originalOptions, attribute, attributes, globalOptions);\n        }\n\n        return v.format(message, {attribute: v.prettify(attribute), type: type});\n      }\n    }, {\n      types: {\n        object: function(value) {\n          return v.isObject(value) && !v.isArray(value);\n        },\n        array: v.isArray,\n        integer: v.isInteger,\n        number: v.isNumber,\n        string: v.isString,\n        date: v.isDate,\n        boolean: v.isBoolean\n      },\n      messages: {}\n    })\n  };\n\n  validate.formatters = {\n    detailed: function(errors) {return errors;},\n    flat: v.flattenErrorsToArray,\n    grouped: function(errors) {\n      var attr;\n\n      errors = v.groupErrorsByAttribute(errors);\n      for (attr in errors) {\n        errors[attr] = v.flattenErrorsToArray(errors[attr]);\n      }\n      return errors;\n    },\n    constraint: function(errors) {\n      var attr;\n      errors = v.groupErrorsByAttribute(errors);\n      for (attr in errors) {\n        errors[attr] = errors[attr].map(function(result) {\n          return result.validator;\n        }).sort();\n      }\n      return errors;\n    }\n  };\n\n  validate.exposeModule(validate, this, exports, module, __webpack_require__.amdD);\n}).call(this,\n         true ? /* istanbul ignore next */ exports : 0,\n         true ? /* istanbul ignore next */ module : 0,\n        __webpack_require__.amdD);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3ZhbGlkYXRlLmpzL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNLEdBQUcsTUFBTSxHQUFHLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSw0REFBNEQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxLQUFLLElBQUksb0JBQW9CO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUixtREFBbUQsT0FBTztBQUMx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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsd0JBQU07QUFDL0QsQ0FBQztBQUNELFFBQVEsS0FBOEIsd0NBQXdDLENBQUk7QUFDbEYsUUFBUSxLQUE2Qix1Q0FBdUMsQ0FBSTtBQUNoRixRQUFRLHdCQUF3RSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdmFsaWRhdGUuanMvdmFsaWRhdGUuanM/MTdkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHZhbGlkYXRlLmpzIDAuMTMuMVxuICpcbiAqIChjKSAyMDEzLTIwMTkgTmlja2xhcyBBbnNtYW4sIDIwMTMgV3JhcHBcbiAqIFZhbGlkYXRlLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogRm9yIGFsbCBkZXRhaWxzIGFuZCBkb2N1bWVudGF0aW9uOlxuICogaHR0cDovL3ZhbGlkYXRlanMub3JnL1xuICovXG5cbihmdW5jdGlvbihleHBvcnRzLCBtb2R1bGUsIGRlZmluZSkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvLyBUaGUgbWFpbiBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSB2YWxpZGF0b3JzIHNwZWNpZmllZCBieSB0aGUgY29uc3RyYWludHMuXG4gIC8vIFRoZSBvcHRpb25zIGFyZSB0aGUgZm9sbG93aW5nOlxuICAvLyAgIC0gZm9ybWF0IChzdHJpbmcpIC0gQW4gb3B0aW9uIHRoYXQgY29udHJvbHMgaG93IHRoZSByZXR1cm5lZCB2YWx1ZSBpcyBmb3JtYXR0ZWRcbiAgLy8gICAgICogZmxhdCAtIFJldHVybnMgYSBmbGF0IGFycmF5IG9mIGp1c3QgdGhlIGVycm9yIG1lc3NhZ2VzXG4gIC8vICAgICAqIGdyb3VwZWQgLSBSZXR1cm5zIHRoZSBtZXNzYWdlcyBncm91cGVkIGJ5IGF0dHJpYnV0ZSAoZGVmYXVsdClcbiAgLy8gICAgICogZGV0YWlsZWQgLSBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByYXcgdmFsaWRhdGlvbiBkYXRhXG4gIC8vICAgLSBmdWxsTWVzc2FnZXMgKGJvb2xlYW4pIC0gSWYgYHRydWVgIChkZWZhdWx0KSB0aGUgYXR0cmlidXRlIG5hbWUgaXMgcHJlcGVuZGVkIHRvIHRoZSBlcnJvci5cbiAgLy9cbiAgLy8gUGxlYXNlIG5vdGUgdGhhdCB0aGUgb3B0aW9ucyBhcmUgYWxzbyBwYXNzZWQgdG8gZWFjaCB2YWxpZGF0b3IuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB2Lm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHJlc3VsdHMgPSB2LnJ1blZhbGlkYXRpb25zKGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzLCBvcHRpb25zKVxuICAgICAgLCBhdHRyXG4gICAgICAsIHZhbGlkYXRvcjtcblxuICAgIGlmIChyZXN1bHRzLnNvbWUoZnVuY3Rpb24ocikgeyByZXR1cm4gdi5pc1Byb21pc2Uoci5lcnJvcik7IH0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2UgdmFsaWRhdGUuYXN5bmMgaWYgeW91IHdhbnQgc3VwcG9ydCBmb3IgcHJvbWlzZXNcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZS5wcm9jZXNzVmFsaWRhdGlvblJlc3VsdHMocmVzdWx0cywgb3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIHYgPSB2YWxpZGF0ZTtcblxuICAvLyBDb3BpZXMgb3ZlciBhdHRyaWJ1dGVzIGZyb20gb25lIG9yIG1vcmUgc291cmNlcyB0byBhIHNpbmdsZSBkZXN0aW5hdGlvbi5cbiAgLy8gVmVyeSBtdWNoIHNpbWlsYXIgdG8gdW5kZXJzY29yZSdzIGV4dGVuZC5cbiAgLy8gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSB0YXJnZXQgb2JqZWN0IGFuZCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyB3aWxsIGJlXG4gIC8vIHVzZWQgYXMgc291cmNlcy5cbiAgdi5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gc291cmNlKSB7XG4gICAgICAgIG9ialthdHRyXSA9IHNvdXJjZVthdHRyXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIHYuZXh0ZW5kKHZhbGlkYXRlLCB7XG4gICAgLy8gVGhpcyBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgbGlicmFyeSBhcyBhIHNlbXZlci5cbiAgICAvLyBUaGUgdG9TdHJpbmcgZnVuY3Rpb24gd2lsbCBhbGxvdyBpdCB0byBiZSBjb2VyY2VkIGludG8gYSBzdHJpbmdcbiAgICB2ZXJzaW9uOiB7XG4gICAgICBtYWpvcjogMCxcbiAgICAgIG1pbm9yOiAxMyxcbiAgICAgIHBhdGNoOiAxLFxuICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2ZXJzaW9uID0gdi5mb3JtYXQoXCIle21ham9yfS4le21pbm9yfS4le3BhdGNofVwiLCB2LnZlcnNpb24pO1xuICAgICAgICBpZiAoIXYuaXNFbXB0eSh2LnZlcnNpb24ubWV0YWRhdGEpKSB7XG4gICAgICAgICAgdmVyc2lvbiArPSBcIitcIiArIHYudmVyc2lvbi5tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQmVsb3cgaXMgdGhlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSB1c2VkIGluIHZhbGlkYXRlLmpzXG5cbiAgICAvLyBUaGUgY29uc3RydWN0b3Igb2YgdGhlIFByb21pc2UgaW1wbGVtZW50YXRpb24uXG4gICAgLy8gSWYgeW91IGFyZSB1c2luZyBRLmpzLCBSU1ZQIG9yIGFueSBvdGhlciBBKyBjb21wYXRpYmxlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gb3ZlcnJpZGUgdGhpcyBhdHRyaWJ1dGUgdG8gYmUgdGhlIGNvbnN0cnVjdG9yIG9mIHRoYXQgcHJvbWlzZS5cbiAgICAvLyBTaW5jZSBqUXVlcnkgcHJvbWlzZXMgYXJlbid0IEErIGNvbXBhdGlibGUgdGhleSB3b24ndCB3b3JrLlxuICAgIFByb21pc2U6IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiID8gUHJvbWlzZSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGwsXG5cbiAgICBFTVBUWV9TVFJJTkdfUkVHRVhQOiAvXlxccyokLyxcblxuICAgIC8vIFJ1bnMgdGhlIHZhbGlkYXRvcnMgc3BlY2lmaWVkIGJ5IHRoZSBjb25zdHJhaW50cyBvYmplY3QuXG4gICAgLy8gV2lsbCByZXR1cm4gYW4gYXJyYXkgb2YgdGhlIGZvcm1hdDpcbiAgICAvLyAgICAgW3thdHRyaWJ1dGU6IFwiPGF0dHJpYnV0ZSBuYW1lPlwiLCBlcnJvcjogXCI8dmFsaWRhdGlvbiByZXN1bHQ+XCJ9LCAuLi5dXG4gICAgcnVuVmFsaWRhdGlvbnM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdXG4gICAgICAgICwgYXR0clxuICAgICAgICAsIHZhbGlkYXRvck5hbWVcbiAgICAgICAgLCB2YWx1ZVxuICAgICAgICAsIHZhbGlkYXRvcnNcbiAgICAgICAgLCB2YWxpZGF0b3JcbiAgICAgICAgLCB2YWxpZGF0b3JPcHRpb25zXG4gICAgICAgICwgZXJyb3I7XG5cbiAgICAgIGlmICh2LmlzRG9tRWxlbWVudChhdHRyaWJ1dGVzKSB8fCB2LmlzSnF1ZXJ5RWxlbWVudChhdHRyaWJ1dGVzKSkge1xuICAgICAgICBhdHRyaWJ1dGVzID0gdi5jb2xsZWN0Rm9ybVZhbHVlcyhhdHRyaWJ1dGVzKTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9vcHMgdGhyb3VnaCBlYWNoIGNvbnN0cmFpbnRzLCBmaW5kcyB0aGUgY29ycmVjdCB2YWxpZGF0b3IgYW5kIHJ1biBpdC5cbiAgICAgIGZvciAoYXR0ciBpbiBjb25zdHJhaW50cykge1xuICAgICAgICB2YWx1ZSA9IHYuZ2V0RGVlcE9iamVjdFZhbHVlKGF0dHJpYnV0ZXMsIGF0dHIpO1xuICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgY29uc3RyYWludHMgZm9yIGFuIGF0dHJpYnV0ZSB0byBiZSBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUsIGF0dHJpYnV0ZSBuYW1lLCB0aGUgY29tcGxldGUgZGljdCBvZlxuICAgICAgICAvLyBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgdGhlIG9wdGlvbnMgYW5kIGNvbnN0cmFpbnRzIHBhc3NlZCBpbi5cbiAgICAgICAgLy8gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBoYXZlIGRpZmZlcmVudFxuICAgICAgICAvLyB2YWxpZGF0aW9ucyBkZXBlbmRpbmcgb24gdGhlIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgICAgdmFsaWRhdG9ycyA9IHYucmVzdWx0KGNvbnN0cmFpbnRzW2F0dHJdLCB2YWx1ZSwgYXR0cmlidXRlcywgYXR0ciwgb3B0aW9ucywgY29uc3RyYWludHMpO1xuXG4gICAgICAgIGZvciAodmFsaWRhdG9yTmFtZSBpbiB2YWxpZGF0b3JzKSB7XG4gICAgICAgICAgdmFsaWRhdG9yID0gdi52YWxpZGF0b3JzW3ZhbGlkYXRvck5hbWVdO1xuXG4gICAgICAgICAgaWYgKCF2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gdi5mb3JtYXQoXCJVbmtub3duIHZhbGlkYXRvciAle25hbWV9XCIsIHtuYW1lOiB2YWxpZGF0b3JOYW1lfSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbGlkYXRvck9wdGlvbnMgPSB2YWxpZGF0b3JzW3ZhbGlkYXRvck5hbWVdO1xuICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBvcHRpb25zIHRvIGJlIGEgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiB3aWxsIGJlXG4gICAgICAgICAgLy8gY2FsbGVkIHdpdGggdGhlIHZhbHVlLCBhdHRyaWJ1dGUgbmFtZSwgdGhlIGNvbXBsZXRlIGRpY3Qgb2ZcbiAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgdGhlIG9wdGlvbnMgYW5kIGNvbnN0cmFpbnRzIHBhc3NlZCBpbi5cbiAgICAgICAgICAvLyBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGhhdmUgZGlmZmVyZW50XG4gICAgICAgICAgLy8gdmFsaWRhdGlvbnMgZGVwZW5kaW5nIG9uIHRoZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgICAgdmFsaWRhdG9yT3B0aW9ucyA9IHYucmVzdWx0KHZhbGlkYXRvck9wdGlvbnMsIHZhbHVlLCBhdHRyaWJ1dGVzLCBhdHRyLCBvcHRpb25zLCBjb25zdHJhaW50cyk7XG4gICAgICAgICAgaWYgKCF2YWxpZGF0b3JPcHRpb25zKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogdmFsaWRhdG9yTmFtZSxcbiAgICAgICAgICAgIGdsb2JhbE9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgb3B0aW9uczogdmFsaWRhdG9yT3B0aW9ucyxcbiAgICAgICAgICAgIGVycm9yOiB2YWxpZGF0b3IuY2FsbCh2YWxpZGF0b3IsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLy8gVGFrZXMgdGhlIG91dHB1dCBmcm9tIHJ1blZhbGlkYXRpb25zIGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgY29ycmVjdFxuICAgIC8vIG91dHB1dCBmb3JtYXQuXG4gICAgcHJvY2Vzc1ZhbGlkYXRpb25SZXN1bHRzOiBmdW5jdGlvbihlcnJvcnMsIG9wdGlvbnMpIHtcbiAgICAgIGVycm9ycyA9IHYucHJ1bmVFbXB0eUVycm9ycyhlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgZXJyb3JzID0gdi5leHBhbmRNdWx0aXBsZUVycm9ycyhlcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgZXJyb3JzID0gdi5jb252ZXJ0RXJyb3JNZXNzYWdlcyhlcnJvcnMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgXCJncm91cGVkXCI7XG5cbiAgICAgIGlmICh0eXBlb2Ygdi5mb3JtYXR0ZXJzW2Zvcm1hdF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3JzID0gdi5mb3JtYXR0ZXJzW2Zvcm1hdF0oZXJyb3JzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih2LmZvcm1hdChcIlVua25vd24gZm9ybWF0ICV7Zm9ybWF0fVwiLCBvcHRpb25zKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2LmlzRW1wdHkoZXJyb3JzKSA/IHVuZGVmaW5lZCA6IGVycm9ycztcbiAgICB9LFxuXG4gICAgLy8gUnVucyB0aGUgdmFsaWRhdGlvbnMgd2l0aCBzdXBwb3J0IGZvciBwcm9taXNlcy5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHNldHRsZWQgd2hlbiBhbGwgdGhlXG4gICAgLy8gdmFsaWRhdGlvbiBwcm9taXNlcyBoYXZlIGJlZW4gY29tcGxldGVkLlxuICAgIC8vIEl0IGNhbiBiZSBjYWxsZWQgZXZlbiBpZiBubyB2YWxpZGF0aW9ucyByZXR1cm5lZCBhIHByb21pc2UuXG4gICAgYXN5bmM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gdi5leHRlbmQoe30sIHYuYXN5bmMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBXcmFwRXJyb3JzID0gb3B0aW9ucy53cmFwRXJyb3JzIHx8IGZ1bmN0aW9uKGVycm9ycykge1xuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgfTtcblxuICAgICAgLy8gUmVtb3ZlcyB1bmtub3duIGF0dHJpYnV0ZXNcbiAgICAgIGlmIChvcHRpb25zLmNsZWFuQXR0cmlidXRlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHYuY2xlYW5BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdHMgPSB2LnJ1blZhbGlkYXRpb25zKGF0dHJpYnV0ZXMsIGNvbnN0cmFpbnRzLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIG5ldyB2LlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHYud2FpdEZvclJlc3VsdHMocmVzdWx0cykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXJyb3JzID0gdi5wcm9jZXNzVmFsaWRhdGlvblJlc3VsdHMocmVzdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBXcmFwRXJyb3JzKGVycm9ycywgb3B0aW9ucywgYXR0cmlidXRlcywgY29uc3RyYWludHMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShhdHRyaWJ1dGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzaW5nbGU6IGZ1bmN0aW9uKHZhbHVlLCBjb25zdHJhaW50cywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB2LnNpbmdsZS5vcHRpb25zLCBvcHRpb25zLCB7XG4gICAgICAgIGZvcm1hdDogXCJmbGF0XCIsXG4gICAgICAgIGZ1bGxNZXNzYWdlczogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHYoe3NpbmdsZTogdmFsdWV9LCB7c2luZ2xlOiBjb25zdHJhaW50c30sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gYWxsIHByb21pc2VzIGluIHRoZSByZXN1bHRzIGFycmF5XG4gICAgLy8gYXJlIHNldHRsZWQuIFRoZSBwcm9taXNlIHJldHVybmVkIGZyb20gdGhpcyBmdW5jdGlvbiBpcyBhbHdheXMgcmVzb2x2ZWQsXG4gICAgLy8gbmV2ZXIgcmVqZWN0ZWQuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGUgaW5wdXQgYXJndW1lbnQsIGl0IHJlcGxhY2VzIHRoZSBwcm9taXNlc1xuICAgIC8vIHdpdGggdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHByb21pc2UuXG4gICAgd2FpdEZvclJlc3VsdHM6IGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIC8vIENyZWF0ZSBhIHNlcXVlbmNlIG9mIGFsbCB0aGUgcmVzdWx0cyBzdGFydGluZyB3aXRoIGEgcmVzb2x2ZWQgcHJvbWlzZS5cbiAgICAgIHJldHVybiByZXN1bHRzLnJlZHVjZShmdW5jdGlvbihtZW1vLCByZXN1bHQpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZXN1bHQgaXNuJ3QgYSBwcm9taXNlIHNraXAgaXQgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICBpZiAoIXYuaXNQcm9taXNlKHJlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZW1vLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5lcnJvci50aGVuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3IgPSBlcnJvciB8fCBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIG5ldyB2LlByb21pc2UoZnVuY3Rpb24ocikgeyByKCk7IH0pKTsgLy8gQSByZXNvbHZlZCBwcm9taXNlXG4gICAgfSxcblxuICAgIC8vIElmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhIGNhbGw6IGZ1bmN0aW9uIHRoZSBhbmQ6IGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWVcbiAgICAvLyBvdGhlcndpc2UganVzdCByZXR1cm4gdGhlIHZhbHVlLiBBZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCBhc1xuICAgIC8vIGFyZ3VtZW50cyB0byB0aGUgZnVuY3Rpb24uXG4gICAgLy8gRXhhbXBsZTpcbiAgICAvLyBgYGBcbiAgICAvLyByZXN1bHQoJ2ZvbycpIC8vICdmb28nXG4gICAgLy8gcmVzdWx0KE1hdGgubWF4LCAxLCAyKSAvLyAyXG4gICAgLy8gYGBgXG4gICAgcmVzdWx0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIuIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29uc2lkZXIgTmFOIGFcbiAgICAvLyBudW1iZXIgbGlrZSBtYW55IG90aGVyIGBpc051bWJlcmAgZnVuY3Rpb25zIGRvLlxuICAgIGlzTnVtYmVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBmYWxzZSBpZiB0aGUgb2JqZWN0IGlzIG5vdCBhIGZ1bmN0aW9uXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgfSxcblxuICAgIC8vIEEgc2ltcGxlIGNoZWNrIHRvIHZlcmlmeSB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyLiBVc2VzIGBpc051bWJlcmBcbiAgICAvLyBhbmQgYSBzaW1wbGUgbW9kdWxvIGNoZWNrLlxuICAgIGlzSW50ZWdlcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2LmlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAlIDEgPT09IDA7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH0sXG5cbiAgICAvLyBVc2VzIHRoZSBgT2JqZWN0YCBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYW4gb2JqZWN0LlxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICAgIH0sXG5cbiAgICAvLyBTaW1wbHkgY2hlY2tzIGlmIHRoZSBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYSBkYXRlXG4gICAgaXNEYXRlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEYXRlO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgYG51bGxgIG9mIGB1bmRlZmluZWRgXG4gICAgaXNEZWZpbmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgYSBwcm9taXNlLiBBbnl0aGluZyB3aXRoIGEgYHRoZW5gXG4gICAgLy8gZnVuY3Rpb24gaXMgY29uc2lkZXJlZCBhIHByb21pc2UuXG4gICAgaXNQcm9taXNlOiBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gISFwICYmIHYuaXNGdW5jdGlvbihwLnRoZW4pO1xuICAgIH0sXG5cbiAgICBpc0pxdWVyeUVsZW1lbnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvICYmIHYuaXNTdHJpbmcoby5qcXVlcnkpO1xuICAgIH0sXG5cbiAgICBpc0RvbUVsZW1lbnQ6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmICghbykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghby5xdWVyeVNlbGVjdG9yQWxsIHx8ICFvLnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5pc09iamVjdChkb2N1bWVudCkgJiYgbyA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4NDM4MC82OTkzMDRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbyAmJlxuICAgICAgICAgIHR5cGVvZiBvID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgbyAhPT0gbnVsbCAmJlxuICAgICAgICAgIG8ubm9kZVR5cGUgPT09IDEgJiZcbiAgICAgICAgICB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBhdHRyO1xuXG4gICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIGVtcHR5XG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZnVuY3Rpb25zIGFyZSBub24gZW1wdHlcbiAgICAgIGlmICh2LmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hpdGVzcGFjZSBvbmx5IHN0cmluZ3MgYXJlIGVtcHR5XG4gICAgICBpZiAodi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHYuRU1QVFlfU1RSSU5HX1JFR0VYUC50ZXN0KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yIGFycmF5cyB3ZSB1c2UgdGhlIGxlbmd0aCBwcm9wZXJ0eVxuICAgICAgaWYgKHYuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gRGF0ZXMgaGF2ZSBubyBhdHRyaWJ1dGVzIGJ1dCBhcmVuJ3QgZW1wdHlcbiAgICAgIGlmICh2LmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBmaW5kIGF0IGxlYXN0IG9uZSBwcm9wZXJ0eSB3ZSBjb25zaWRlciBpdCBub24gZW1wdHlcbiAgICAgIGlmICh2LmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGF0dHIgaW4gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gRm9ybWF0cyB0aGUgc3BlY2lmaWVkIHN0cmluZ3Mgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzIGxpa2Ugc286XG4gICAgLy8gYGBgXG4gICAgLy8gZm9ybWF0KFwiRm9vOiAle2Zvb31cIiwge2ZvbzogXCJiYXJcIn0pIC8vIFwiRm9vIGJhclwiXG4gICAgLy8gYGBgXG4gICAgLy8gSWYgeW91IHdhbnQgdG8gd3JpdGUgJXsuLi59IHdpdGhvdXQgaGF2aW5nIGl0IHJlcGxhY2VkIHNpbXBseVxuICAgIC8vIHByZWZpeCBpdCB3aXRoICUgbGlrZSB0aGlzIGBGb286ICUle2Zvb31gIGFuZCBpdCB3aWxsIGJlIHJldHVybmVkXG4gICAgLy8gYXMgYFwiRm9vOiAle2Zvb31cImBcbiAgICBmb3JtYXQ6IHYuZXh0ZW5kKGZ1bmN0aW9uKHN0ciwgdmFscykge1xuICAgICAgaWYgKCF2LmlzU3RyaW5nKHN0cikpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSh2LmZvcm1hdC5GT1JNQVRfUkVHRVhQLCBmdW5jdGlvbihtMCwgbTEsIG0yKSB7XG4gICAgICAgIGlmIChtMSA9PT0gJyUnKSB7XG4gICAgICAgICAgcmV0dXJuIFwiJXtcIiArIG0yICsgXCJ9XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWxzW20yXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIC8vIEZpbmRzICV7a2V5fSBzdHlsZSBwYXR0ZXJucyBpbiB0aGUgZ2l2ZW4gc3RyaW5nXG4gICAgICBGT1JNQVRfUkVHRVhQOiAvKCU/KSVcXHsoW15cXH1dKylcXH0vZ1xuICAgIH0pLFxuXG4gICAgLy8gXCJQcmV0dGlmaWVzXCIgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAvLyBQcmV0dGlmeWluZyBtZWFucyByZXBsYWNpbmcgWy5cXF8tXSB3aXRoIHNwYWNlcyBhcyB3ZWxsIGFzIHNwbGl0dGluZ1xuICAgIC8vIGNhbWVsIGNhc2Ugd29yZHMuXG4gICAgcHJldHRpZnk6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHYuaXNOdW1iZXIoc3RyKSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDIgZGVjaW1hbHMgcm91bmQgaXQgdG8gdHdvXG4gICAgICAgIGlmICgoc3RyICogMTAwKSAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gXCJcIiArIHN0cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChNYXRoLnJvdW5kKHN0ciAqIDEwMCkgLyAxMDApLnRvRml4ZWQoMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHYuaXNBcnJheShzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHIubWFwKGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHYucHJldHRpZnkocyk7IH0pLmpvaW4oXCIsIFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYuaXNPYmplY3Qoc3RyKSkge1xuICAgICAgICBpZiAoIXYuaXNEZWZpbmVkKHN0ci50b1N0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5zdXJlIHRoZSBzdHJpbmcgaXMgYWN0dWFsbHkgYSBzdHJpbmdcbiAgICAgIHN0ciA9IFwiXCIgKyBzdHI7XG5cbiAgICAgIHJldHVybiBzdHJcbiAgICAgICAgLy8gU3BsaXRzIGtleXMgc2VwYXJhdGVkIGJ5IHBlcmlvZHNcbiAgICAgICAgLnJlcGxhY2UoLyhbXlxcc10pXFwuKFteXFxzXSkvZywgJyQxICQyJylcbiAgICAgICAgLy8gUmVtb3ZlcyBiYWNrc2xhc2hlc1xuICAgICAgICAucmVwbGFjZSgvXFxcXCsvZywgJycpXG4gICAgICAgIC8vIFJlcGxhY2VzIC0gYW5kIC0gd2l0aCBzcGFjZVxuICAgICAgICAucmVwbGFjZSgvW18tXS9nLCAnICcpXG4gICAgICAgIC8vIFNwbGl0cyBjYW1lbCBjYXNlZCB3b3Jkc1xuICAgICAgICAucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgZnVuY3Rpb24obTAsIG0xLCBtMikge1xuICAgICAgICAgIHJldHVybiBcIlwiICsgbTEgKyBcIiBcIiArIG0yLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICBzdHJpbmdpZnlWYWx1ZTogZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcmV0dGlmeSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wcmV0dGlmeSB8fCB2LnByZXR0aWZ5O1xuICAgICAgcmV0dXJuIHByZXR0aWZ5KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9LFxuXG4gICAgaXNBcnJheTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBvYmplY3QgaXMgYSBoYXNoLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIGFuIG9iamVjdCB0aGF0XG4gICAgLy8gaXMgbmVpdGhlciBhbiBhcnJheSBub3IgYSBmdW5jdGlvbi5cbiAgICBpc0hhc2g6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdi5pc09iamVjdCh2YWx1ZSkgJiYgIXYuaXNBcnJheSh2YWx1ZSkgJiYgIXYuaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfSxcblxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihvYmosIHZhbHVlKSB7XG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHYuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmouaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlIGluIG9iajtcbiAgICB9LFxuXG4gICAgdW5pcXVlOiBmdW5jdGlvbihhcnJheSkge1xuICAgICAgaWYgKCF2LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24oZWwsIGluZGV4LCBhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbCkgPT0gaW5kZXg7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZm9yRWFjaEtleUluS2V5cGF0aDogZnVuY3Rpb24ob2JqZWN0LCBrZXlwYXRoLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCF2LmlzU3RyaW5nKGtleXBhdGgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXkgPSBcIlwiXG4gICAgICAgICwgaVxuICAgICAgICAsIGVzY2FwZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICBzd2l0Y2ggKGtleXBhdGhbaV0pIHtcbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgICAgICAgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGtleSArPSAnLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmplY3QgPSBjYWxsYmFjayhvYmplY3QsIGtleSwgZmFsc2UpO1xuICAgICAgICAgICAgICBrZXkgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdcXFxcJzpcbiAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgICAgICAgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGtleSArPSAnXFxcXCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlc2NhcGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgICAgICBrZXkgKz0ga2V5cGF0aFtpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsYmFjayhvYmplY3QsIGtleSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIGdldERlZXBPYmplY3RWYWx1ZTogZnVuY3Rpb24ob2JqLCBrZXlwYXRoKSB7XG4gICAgICBpZiAoIXYuaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdi5mb3JFYWNoS2V5SW5LZXlwYXRoKG9iaiwga2V5cGF0aCwgZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKHYuaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHZhbHVlcyBvZiB0aGUgZm9ybS5cbiAgICAvLyBJdCB1c2VzIHRoZSBpbnB1dCBuYW1lIGFzIGtleSBhbmQgdGhlIHZhbHVlIGFzIHZhbHVlXG4gICAgLy8gU28gZm9yIGV4YW1wbGUgdGhpczpcbiAgICAvLyA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiZW1haWxcIiB2YWx1ZT1cImZvb0BiYXIuY29tXCIgLz5cbiAgICAvLyB3b3VsZCByZXR1cm46XG4gICAgLy8ge2VtYWlsOiBcImZvb0BiYXIuY29tXCJ9XG4gICAgY29sbGVjdEZvcm1WYWx1ZXM6IGZ1bmN0aW9uKGZvcm0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB7fVxuICAgICAgICAsIGlcbiAgICAgICAgLCBqXG4gICAgICAgICwgaW5wdXRcbiAgICAgICAgLCBpbnB1dHNcbiAgICAgICAgLCBvcHRpb25cbiAgICAgICAgLCB2YWx1ZTtcblxuICAgICAgaWYgKHYuaXNKcXVlcnlFbGVtZW50KGZvcm0pKSB7XG4gICAgICAgIGZvcm0gPSBmb3JtWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZvcm0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGlucHV0cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWVdLCB0ZXh0YXJlYVtuYW1lXVwiKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dHMuaXRlbShpKTtcblxuICAgICAgICBpZiAodi5pc0RlZmluZWQoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZ25vcmVkXCIpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBpbnB1dC5uYW1lLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFxcXFxcLlwiKTtcbiAgICAgICAgdmFsdWUgPSB2LnNhbml0aXplRm9ybVZhbHVlKGlucHV0LnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID8gK3ZhbHVlIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuYXR0cmlidXRlcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFpbnB1dC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW25hbWVdIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gaW5wdXQuY2hlY2tlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICAgICAgaWYgKCFpbnB1dC5jaGVja2VkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tuYW1lXSB8fCBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaW5wdXRzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKFwic2VsZWN0W25hbWVdXCIpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnB1dCA9IGlucHV0cy5pdGVtKGkpO1xuICAgICAgICBpZiAodi5pc0RlZmluZWQoaW5wdXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pZ25vcmVkXCIpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0Lm11bHRpcGxlKSB7XG4gICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICBmb3IgKGogaW4gaW5wdXQub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9uID0gaW5wdXQub3B0aW9uc1tqXTtcbiAgICAgICAgICAgICBpZiAob3B0aW9uICYmIG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHYuc2FuaXRpemVGb3JtVmFsdWUob3B0aW9uLnZhbHVlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdmFsID0gdHlwZW9mIGlucHV0Lm9wdGlvbnNbaW5wdXQuc2VsZWN0ZWRJbmRleF0gIT09ICd1bmRlZmluZWQnID8gaW5wdXQub3B0aW9uc1tpbnB1dC5zZWxlY3RlZEluZGV4XS52YWx1ZSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovICcnO1xuICAgICAgICAgIHZhbHVlID0gdi5zYW5pdGl6ZUZvcm1WYWx1ZShfdmFsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbaW5wdXQubmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuXG4gICAgc2FuaXRpemVGb3JtVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy50cmltICYmIHYuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5udWxsaWZ5ICE9PSBmYWxzZSAmJiB2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoIXYuaXNTdHJpbmcoc3RyKSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYWxsIGVycm9ycyB3aG8ncyBlcnJvciBhdHRyaWJ1dGUgaXMgZW1wdHkgKG51bGwgb3IgdW5kZWZpbmVkKVxuICAgIHBydW5lRW1wdHlFcnJvcnM6IGZ1bmN0aW9uKGVycm9ycykge1xuICAgICAgcmV0dXJuIGVycm9ycy5maWx0ZXIoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICF2LmlzRW1wdHkoZXJyb3IuZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEluXG4gICAgLy8gW3tlcnJvcjogW1wiZXJyMVwiLCBcImVycjJcIl0sIC4uLn1dXG4gICAgLy8gT3V0XG4gICAgLy8gW3tlcnJvcjogXCJlcnIxXCIsIC4uLn0sIHtlcnJvcjogXCJlcnIyXCIsIC4uLn1dXG4gICAgLy9cbiAgICAvLyBBbGwgYXR0cmlidXRlcyBpbiBhbiBlcnJvciB3aXRoIG11bHRpcGxlIG1lc3NhZ2VzIGFyZSBkdXBsaWNhdGVkXG4gICAgLy8gd2hlbiBleHBhbmRpbmcgdGhlIGVycm9ycy5cbiAgICBleHBhbmRNdWx0aXBsZUVycm9yczogZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAvLyBSZW1vdmVzIGVycm9ycyB3aXRob3V0IGEgbWVzc2FnZVxuICAgICAgICBpZiAodi5pc0FycmF5KGVycm9yLmVycm9yKSkge1xuICAgICAgICAgIGVycm9yLmVycm9yLmZvckVhY2goZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICByZXQucHVzaCh2LmV4dGVuZCh7fSwgZXJyb3IsIHtlcnJvcjogbXNnfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC5wdXNoKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0cyB0aGUgZXJyb3IgbWVzYWdlcyBieSBwcmVwZW5kaW5nIHRoZSBhdHRyaWJ1dGUgbmFtZSB1bmxlc3MgdGhlXG4gICAgLy8gbWVzc2FnZSBpcyBwcmVmaXhlZCBieSBeXG4gICAgY29udmVydEVycm9yTWVzc2FnZXM6IGZ1bmN0aW9uKGVycm9ycywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhciByZXQgPSBbXVxuICAgICAgICAsIHByZXR0aWZ5ID0gb3B0aW9ucy5wcmV0dGlmeSB8fCB2LnByZXR0aWZ5O1xuICAgICAgZXJyb3JzLmZvckVhY2goZnVuY3Rpb24oZXJyb3JJbmZvKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHYucmVzdWx0KGVycm9ySW5mby5lcnJvcixcbiAgICAgICAgICAgIGVycm9ySW5mby52YWx1ZSxcbiAgICAgICAgICAgIGVycm9ySW5mby5hdHRyaWJ1dGUsXG4gICAgICAgICAgICBlcnJvckluZm8ub3B0aW9ucyxcbiAgICAgICAgICAgIGVycm9ySW5mby5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZXJyb3JJbmZvLmdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICAgIGlmICghdi5pc1N0cmluZyhlcnJvcikpIHtcbiAgICAgICAgICByZXQucHVzaChlcnJvckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvclswXSA9PT0gJ14nKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvci5zbGljZSgxKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZ1bGxNZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBlcnJvciA9IHYuY2FwaXRhbGl6ZShwcmV0dGlmeShlcnJvckluZm8uYXR0cmlidXRlKSkgKyBcIiBcIiArIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yID0gZXJyb3IucmVwbGFjZSgvXFxcXFxcXi9nLCBcIl5cIik7XG4gICAgICAgIGVycm9yID0gdi5mb3JtYXQoZXJyb3IsIHtcbiAgICAgICAgICB2YWx1ZTogdi5zdHJpbmdpZnlWYWx1ZShlcnJvckluZm8udmFsdWUsIG9wdGlvbnMpXG4gICAgICAgIH0pO1xuICAgICAgICByZXQucHVzaCh2LmV4dGVuZCh7fSwgZXJyb3JJbmZvLCB7ZXJyb3I6IGVycm9yfSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvLyBJbjpcbiAgICAvLyBbe2F0dHJpYnV0ZTogXCI8YXR0cmlidXRlTmFtZT5cIiwgLi4ufV1cbiAgICAvLyBPdXQ6XG4gICAgLy8ge1wiPGF0dHJpYnV0ZU5hbWU+XCI6IFt7YXR0cmlidXRlOiBcIjxhdHRyaWJ1dGVOYW1lPlwiLCAuLi59XX1cbiAgICBncm91cEVycm9yc0J5QXR0cmlidXRlOiBmdW5jdGlvbihlcnJvcnMpIHtcbiAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIHZhciBsaXN0ID0gcmV0W2Vycm9yLmF0dHJpYnV0ZV07XG4gICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRbZXJyb3IuYXR0cmlidXRlXSA9IFtlcnJvcl07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLy8gSW46XG4gICAgLy8gW3tlcnJvcjogXCI8bWVzc2FnZSAxPlwiLCAuLi59LCB7ZXJyb3I6IFwiPG1lc3NhZ2UgMj5cIiwgLi4ufV1cbiAgICAvLyBPdXQ6XG4gICAgLy8gW1wiPG1lc3NhZ2UgMT5cIiwgXCI8bWVzc2FnZSAyPlwiXVxuICAgIGZsYXR0ZW5FcnJvcnNUb0FycmF5OiBmdW5jdGlvbihlcnJvcnMpIHtcbiAgICAgIHJldHVybiBlcnJvcnNcbiAgICAgICAgLm1hcChmdW5jdGlvbihlcnJvcikgeyByZXR1cm4gZXJyb3IuZXJyb3I7IH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24odmFsdWUsIGluZGV4LCBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY2xlYW5BdHRyaWJ1dGVzOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCB3aGl0ZWxpc3QpIHtcbiAgICAgIGZ1bmN0aW9uIHdoaXRlbGlzdENyZWF0b3Iob2JqLCBrZXksIGxhc3QpIHtcbiAgICAgICAgaWYgKHYuaXNPYmplY3Qob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAob2JqW2tleV0gPSBsYXN0ID8gdHJ1ZSA6IHt9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYnVpbGRPYmplY3RXaGl0ZWxpc3Qod2hpdGVsaXN0KSB7XG4gICAgICAgIHZhciBvdyA9IHt9XG4gICAgICAgICAgLCBsYXN0T2JqZWN0XG4gICAgICAgICAgLCBhdHRyO1xuICAgICAgICBmb3IgKGF0dHIgaW4gd2hpdGVsaXN0KSB7XG4gICAgICAgICAgaWYgKCF3aGl0ZWxpc3RbYXR0cl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2LmZvckVhY2hLZXlJbktleXBhdGgob3csIGF0dHIsIHdoaXRlbGlzdENyZWF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xlYW5SZWN1cnNpdmUoYXR0cmlidXRlcywgd2hpdGVsaXN0KSB7XG4gICAgICAgIGlmICghdi5pc09iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IHYuZXh0ZW5kKHt9LCBhdHRyaWJ1dGVzKVxuICAgICAgICAgICwgd1xuICAgICAgICAgICwgYXR0cmlidXRlO1xuXG4gICAgICAgIGZvciAoYXR0cmlidXRlIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB3ID0gd2hpdGVsaXN0W2F0dHJpYnV0ZV07XG5cbiAgICAgICAgICBpZiAodi5pc09iamVjdCh3KSkge1xuICAgICAgICAgICAgcmV0W2F0dHJpYnV0ZV0gPSBjbGVhblJlY3Vyc2l2ZShyZXRbYXR0cmlidXRlXSwgdyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdykge1xuICAgICAgICAgICAgZGVsZXRlIHJldFthdHRyaWJ1dGVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXYuaXNPYmplY3Qod2hpdGVsaXN0KSB8fCAhdi5pc09iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG5cbiAgICAgIHdoaXRlbGlzdCA9IGJ1aWxkT2JqZWN0V2hpdGVsaXN0KHdoaXRlbGlzdCk7XG4gICAgICByZXR1cm4gY2xlYW5SZWN1cnNpdmUoYXR0cmlidXRlcywgd2hpdGVsaXN0KTtcbiAgICB9LFxuXG4gICAgZXhwb3NlTW9kdWxlOiBmdW5jdGlvbih2YWxpZGF0ZSwgcm9vdCwgZXhwb3J0cywgbW9kdWxlLCBkZWZpbmUpIHtcbiAgICAgIGlmIChleHBvcnRzKSB7XG4gICAgICAgIGlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gICAgICAgIGlmICh2YWxpZGF0ZS5pc0Z1bmN0aW9uKGRlZmluZSkgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGU7IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHdhcm46IGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJbdmFsaWRhdGUuanNdIFwiICsgbXNnKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlt2YWxpZGF0ZS5qc10gXCIgKyBtc2cpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFsaWRhdGUudmFsaWRhdG9ycyA9IHtcbiAgICAvLyBQcmVzZW5jZSB2YWxpZGF0ZXMgdGhhdCB0aGUgdmFsdWUgaXNuJ3QgZW1wdHlcbiAgICBwcmVzZW5jZTogZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmFsbG93RW1wdHkgIT09IGZhbHNlID8gIXYuaXNEZWZpbmVkKHZhbHVlKSA6IHYuaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZSB8fCB0aGlzLm1lc3NhZ2UgfHwgXCJjYW4ndCBiZSBibGFua1wiO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGVuZ3RoOiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgYXR0cmlidXRlKSB7XG4gICAgICAvLyBFbXB0eSB2YWx1ZXMgYXJlIGFsbG93ZWRcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgaXMgPSBvcHRpb25zLmlzXG4gICAgICAgICwgbWF4aW11bSA9IG9wdGlvbnMubWF4aW11bVxuICAgICAgICAsIG1pbmltdW0gPSBvcHRpb25zLm1pbmltdW1cbiAgICAgICAgLCB0b2tlbml6ZXIgPSBvcHRpb25zLnRva2VuaXplciB8fCBmdW5jdGlvbih2YWwpIHsgcmV0dXJuIHZhbDsgfVxuICAgICAgICAsIGVyclxuICAgICAgICAsIGVycm9ycyA9IFtdO1xuXG4gICAgICB2YWx1ZSA9IHRva2VuaXplcih2YWx1ZSk7XG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgaWYoIXYuaXNOdW1iZXIobGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5tZXNzYWdlIHx8IHRoaXMubm90VmFsaWQgfHwgXCJoYXMgYW4gaW5jb3JyZWN0IGxlbmd0aFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBJcyBjaGVja3NcbiAgICAgIGlmICh2LmlzTnVtYmVyKGlzKSAmJiBsZW5ndGggIT09IGlzKSB7XG4gICAgICAgIGVyciA9IG9wdGlvbnMud3JvbmdMZW5ndGggfHxcbiAgICAgICAgICB0aGlzLndyb25nTGVuZ3RoIHx8XG4gICAgICAgICAgXCJpcyB0aGUgd3JvbmcgbGVuZ3RoIChzaG91bGQgYmUgJXtjb3VudH0gY2hhcmFjdGVycylcIjtcbiAgICAgICAgZXJyb3JzLnB1c2godi5mb3JtYXQoZXJyLCB7Y291bnQ6IGlzfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5pc051bWJlcihtaW5pbXVtKSAmJiBsZW5ndGggPCBtaW5pbXVtKSB7XG4gICAgICAgIGVyciA9IG9wdGlvbnMudG9vU2hvcnQgfHxcbiAgICAgICAgICB0aGlzLnRvb1Nob3J0IHx8XG4gICAgICAgICAgXCJpcyB0b28gc2hvcnQgKG1pbmltdW0gaXMgJXtjb3VudH0gY2hhcmFjdGVycylcIjtcbiAgICAgICAgZXJyb3JzLnB1c2godi5mb3JtYXQoZXJyLCB7Y291bnQ6IG1pbmltdW19KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2LmlzTnVtYmVyKG1heGltdW0pICYmIGxlbmd0aCA+IG1heGltdW0pIHtcbiAgICAgICAgZXJyID0gb3B0aW9ucy50b29Mb25nIHx8XG4gICAgICAgICAgdGhpcy50b29Mb25nIHx8XG4gICAgICAgICAgXCJpcyB0b28gbG9uZyAobWF4aW11bSBpcyAle2NvdW50fSBjaGFyYWN0ZXJzKVwiO1xuICAgICAgICBlcnJvcnMucHVzaCh2LmZvcm1hdChlcnIsIHtjb3VudDogbWF4aW11bX0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2UgfHwgZXJyb3JzO1xuICAgICAgfVxuICAgIH0sXG4gICAgbnVtZXJpY2FsaXR5OiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucywgYXR0cmlidXRlLCBhdHRyaWJ1dGVzLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICAvLyBFbXB0eSB2YWx1ZXMgYXJlIGZpbmVcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgZXJyb3JzID0gW11cbiAgICAgICAgLCBuYW1lXG4gICAgICAgICwgY291bnRcbiAgICAgICAgLCBjaGVja3MgPSB7XG4gICAgICAgICAgICBncmVhdGVyVGhhbjogICAgICAgICAgZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA+IGM7IH0sXG4gICAgICAgICAgICBncmVhdGVyVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA+PSBjOyB9LFxuICAgICAgICAgICAgZXF1YWxUbzogICAgICAgICAgICAgIGZ1bmN0aW9uKHYsIGMpIHsgcmV0dXJuIHYgPT09IGM7IH0sXG4gICAgICAgICAgICBsZXNzVGhhbjogICAgICAgICAgICAgZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA8IGM7IH0sXG4gICAgICAgICAgICBsZXNzVGhhbk9yRXF1YWxUbzogICAgZnVuY3Rpb24odiwgYykgeyByZXR1cm4gdiA8PSBjOyB9LFxuICAgICAgICAgICAgZGl2aXNpYmxlQnk6ICAgICAgICAgIGZ1bmN0aW9uKHYsIGMpIHsgcmV0dXJuIHYgJSBjID09PSAwOyB9XG4gICAgICAgICAgfVxuICAgICAgICAsIHByZXR0aWZ5ID0gb3B0aW9ucy5wcmV0dGlmeSB8fFxuICAgICAgICAgIChnbG9iYWxPcHRpb25zICYmIGdsb2JhbE9wdGlvbnMucHJldHRpZnkpIHx8XG4gICAgICAgICAgdi5wcmV0dGlmeTtcblxuICAgICAgLy8gU3RyaWN0IHdpbGwgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIGxvb2tpbmcgbnVtYmVyXG4gICAgICBpZiAodi5pc1N0cmluZyh2YWx1ZSkgJiYgb3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBcIl4tPygwfFsxLTldXFxcXGQqKVwiO1xuICAgICAgICBpZiAoIW9wdGlvbnMub25seUludGVnZXIpIHtcbiAgICAgICAgICBwYXR0ZXJuICs9IFwiKFxcXFwuXFxcXGQrKT9cIjtcbiAgICAgICAgfVxuICAgICAgICBwYXR0ZXJuICs9IFwiJFwiO1xuXG4gICAgICAgIGlmICghKG5ldyBSZWdFeHAocGF0dGVybikudGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5ub3RWYWxpZCB8fFxuICAgICAgICAgICAgdGhpcy5ub3RWYWxpZCB8fFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlIHx8XG4gICAgICAgICAgICBcIm11c3QgYmUgYSB2YWxpZCBudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb2VyY2UgdGhlIHZhbHVlIHRvIGEgbnVtYmVyIHVubGVzcyB3ZSdyZSBiZWluZyBzdHJpY3QuXG4gICAgICBpZiAob3B0aW9ucy5ub1N0cmluZ3MgIT09IHRydWUgJiYgdi5pc1N0cmluZyh2YWx1ZSkgJiYgIXYuaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIHdlIHNob3VsZG4ndCBjb250aW51ZSBzaW5jZSBpdCB3aWxsIGNvbXBhcmUgaXQuXG4gICAgICBpZiAoIXYuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2UgfHxcbiAgICAgICAgICBvcHRpb25zLm5vdFZhbGlkIHx8XG4gICAgICAgICAgdGhpcy5ub3RWYWxpZCB8fFxuICAgICAgICAgIHRoaXMubWVzc2FnZSB8fFxuICAgICAgICAgIFwiaXMgbm90IGEgbnVtYmVyXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhbWUgbG9naWMgYXMgYWJvdmUsIHNvcnQgb2YuIERvbid0IGJvdGhlciB3aXRoIGNvbXBhcmlzb25zIGlmIHRoaXNcbiAgICAgIC8vIGRvZXNuJ3QgcGFzcy5cbiAgICAgIGlmIChvcHRpb25zLm9ubHlJbnRlZ2VyICYmICF2LmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICAgIG9wdGlvbnMubm90SW50ZWdlciB8fFxuICAgICAgICAgIHRoaXMubm90SW50ZWdlciB8fFxuICAgICAgICAgIHRoaXMubWVzc2FnZSB8fFxuICAgICAgICAgIFwibXVzdCBiZSBhbiBpbnRlZ2VyXCI7XG4gICAgICB9XG5cbiAgICAgIGZvciAobmFtZSBpbiBjaGVja3MpIHtcbiAgICAgICAgY291bnQgPSBvcHRpb25zW25hbWVdO1xuICAgICAgICBpZiAodi5pc051bWJlcihjb3VudCkgJiYgIWNoZWNrc1tuYW1lXSh2YWx1ZSwgY291bnQpKSB7XG4gICAgICAgICAgLy8gVGhpcyBwaWNrcyB0aGUgZGVmYXVsdCBtZXNzYWdlIGlmIHNwZWNpZmllZFxuICAgICAgICAgIC8vIEZvciBleGFtcGxlIHRoZSBncmVhdGVyVGhhbiBjaGVjayB1c2VzIHRoZSBtZXNzYWdlIGZyb21cbiAgICAgICAgICAvLyB0aGlzLm5vdEdyZWF0ZXJUaGFuIHNvIHdlIGNhcGl0YWxpemUgdGhlIG5hbWUgYW5kIHByZXBlbmQgXCJub3RcIlxuICAgICAgICAgIHZhciBrZXkgPSBcIm5vdFwiICsgdi5jYXBpdGFsaXplKG5hbWUpO1xuICAgICAgICAgIHZhciBtc2cgPSBvcHRpb25zW2tleV0gfHxcbiAgICAgICAgICAgIHRoaXNba2V5XSB8fFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlIHx8XG4gICAgICAgICAgICBcIm11c3QgYmUgJXt0eXBlfSAle2NvdW50fVwiO1xuXG4gICAgICAgICAgZXJyb3JzLnB1c2godi5mb3JtYXQobXNnLCB7XG4gICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICB0eXBlOiBwcmV0dGlmeShuYW1lKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vZGQgJiYgdmFsdWUgJSAyICE9PSAxKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG9wdGlvbnMubm90T2RkIHx8XG4gICAgICAgICAgICB0aGlzLm5vdE9kZCB8fFxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlIHx8XG4gICAgICAgICAgICBcIm11c3QgYmUgb2RkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZXZlbiAmJiB2YWx1ZSAlIDIgIT09IDApIHtcbiAgICAgICAgZXJyb3JzLnB1c2gob3B0aW9ucy5ub3RFdmVuIHx8XG4gICAgICAgICAgICB0aGlzLm5vdEV2ZW4gfHxcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSB8fFxuICAgICAgICAgICAgXCJtdXN0IGJlIGV2ZW5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLm1lc3NhZ2UgfHwgZXJyb3JzO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0ZXRpbWU6IHYuZXh0ZW5kKGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXYuaXNGdW5jdGlvbih0aGlzLnBhcnNlKSB8fCAhdi5pc0Z1bmN0aW9uKHRoaXMuZm9ybWF0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIHRoZSBwYXJzZSBhbmQgZm9ybWF0IGZ1bmN0aW9ucyBuZWVkcyB0byBiZSBzZXQgdG8gdXNlIHRoZSBkYXRldGltZS9kYXRlIHZhbGlkYXRvclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW1wdHkgdmFsdWVzIGFyZSBmaW5lXG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgdmFyIGVyclxuICAgICAgICAsIGVycm9ycyA9IFtdXG4gICAgICAgICwgZWFybGllc3QgPSBvcHRpb25zLmVhcmxpZXN0ID8gdGhpcy5wYXJzZShvcHRpb25zLmVhcmxpZXN0LCBvcHRpb25zKSA6IE5hTlxuICAgICAgICAsIGxhdGVzdCA9IG9wdGlvbnMubGF0ZXN0ID8gdGhpcy5wYXJzZShvcHRpb25zLmxhdGVzdCwgb3B0aW9ucykgOiBOYU47XG5cbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIDg2NDAwMDAwIGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGluIGEgZGF5LCB0aGlzIGlzIHVzZWQgdG8gcmVtb3ZlXG4gICAgICAvLyB0aGUgdGltZSBmcm9tIHRoZSBkYXRlXG4gICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IG9wdGlvbnMuZGF0ZU9ubHkgJiYgdmFsdWUgJSA4NjQwMDAwMCAhPT0gMCkge1xuICAgICAgICBlcnIgPSBvcHRpb25zLm5vdFZhbGlkIHx8XG4gICAgICAgICAgb3B0aW9ucy5tZXNzYWdlIHx8XG4gICAgICAgICAgdGhpcy5ub3RWYWxpZCB8fFxuICAgICAgICAgIFwibXVzdCBiZSBhIHZhbGlkIGRhdGVcIjtcbiAgICAgICAgcmV0dXJuIHYuZm9ybWF0KGVyciwge3ZhbHVlOiBhcmd1bWVudHNbMF19KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihlYXJsaWVzdCkgJiYgdmFsdWUgPCBlYXJsaWVzdCkge1xuICAgICAgICBlcnIgPSBvcHRpb25zLnRvb0Vhcmx5IHx8XG4gICAgICAgICAgb3B0aW9ucy5tZXNzYWdlIHx8XG4gICAgICAgICAgdGhpcy50b29FYXJseSB8fFxuICAgICAgICAgIFwibXVzdCBiZSBubyBlYXJsaWVyIHRoYW4gJXtkYXRlfVwiO1xuICAgICAgICBlcnIgPSB2LmZvcm1hdChlcnIsIHtcbiAgICAgICAgICB2YWx1ZTogdGhpcy5mb3JtYXQodmFsdWUsIG9wdGlvbnMpLFxuICAgICAgICAgIGRhdGU6IHRoaXMuZm9ybWF0KGVhcmxpZXN0LCBvcHRpb25zKVxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihsYXRlc3QpICYmIHZhbHVlID4gbGF0ZXN0KSB7XG4gICAgICAgIGVyciA9IG9wdGlvbnMudG9vTGF0ZSB8fFxuICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICAgIHRoaXMudG9vTGF0ZSB8fFxuICAgICAgICAgIFwibXVzdCBiZSBubyBsYXRlciB0aGFuICV7ZGF0ZX1cIjtcbiAgICAgICAgZXJyID0gdi5mb3JtYXQoZXJyLCB7XG4gICAgICAgICAgZGF0ZTogdGhpcy5mb3JtYXQobGF0ZXN0LCBvcHRpb25zKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5mb3JtYXQodmFsdWUsIG9wdGlvbnMpXG4gICAgICAgIH0pO1xuICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdi51bmlxdWUoZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBwYXJzZTogbnVsbCxcbiAgICAgIGZvcm1hdDogbnVsbFxuICAgIH0pLFxuICAgIGRhdGU6IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gdi5leHRlbmQoe30sIG9wdGlvbnMsIHtkYXRlT25seTogdHJ1ZX0pO1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9ycy5kYXRldGltZS5jYWxsKHYudmFsaWRhdG9ycy5kYXRldGltZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHYuaXNTdHJpbmcob3B0aW9ucykgfHwgKG9wdGlvbnMgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7cGF0dGVybjogb3B0aW9uc307XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgdGhpcy5tZXNzYWdlIHx8IFwiaXMgaW52YWxpZFwiXG4gICAgICAgICwgcGF0dGVybiA9IG9wdGlvbnMucGF0dGVyblxuICAgICAgICAsIG1hdGNoO1xuXG4gICAgICAvLyBFbXB0eSB2YWx1ZXMgYXJlIGFsbG93ZWRcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh2LmlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKG9wdGlvbnMucGF0dGVybiwgb3B0aW9ucy5mbGFncyk7XG4gICAgICB9XG4gICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoWzBdLmxlbmd0aCAhPSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbmNsdXNpb246IGZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAvLyBFbXB0eSB2YWx1ZXMgYXJlIGZpbmVcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt3aXRoaW46IG9wdGlvbnN9O1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgaWYgKHYuY29udGFpbnMob3B0aW9ucy53aXRoaW4sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICB0aGlzLm1lc3NhZ2UgfHxcbiAgICAgICAgXCJeJXt2YWx1ZX0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBsaXN0XCI7XG4gICAgICByZXR1cm4gdi5mb3JtYXQobWVzc2FnZSwge3ZhbHVlOiB2YWx1ZX0pO1xuICAgIH0sXG4gICAgZXhjbHVzaW9uOiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgLy8gRW1wdHkgdmFsdWVzIGFyZSBmaW5lXG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodi5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7d2l0aGluOiBvcHRpb25zfTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSB2LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIGlmICghdi5jb250YWlucyhvcHRpb25zLndpdGhpbiwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IHRoaXMubWVzc2FnZSB8fCBcIl4le3ZhbHVlfSBpcyByZXN0cmljdGVkXCI7XG4gICAgICBpZiAodi5pc1N0cmluZyhvcHRpb25zLndpdGhpblt2YWx1ZV0pKSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy53aXRoaW5bdmFsdWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHYuZm9ybWF0KG1lc3NhZ2UsIHt2YWx1ZTogdmFsdWV9KTtcbiAgICB9LFxuICAgIGVtYWlsOiB2LmV4dGVuZChmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgdGhpcy5tZXNzYWdlIHx8IFwiaXMgbm90IGEgdmFsaWQgZW1haWxcIjtcbiAgICAgIC8vIEVtcHR5IHZhbHVlcyBhcmUgZmluZVxuICAgICAgaWYgKCF2LmlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF2LmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5QQVRURVJOLmV4ZWModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIFBBVFRFUk46IC9eKD86W2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2lcbiAgICB9KSxcbiAgICBlcXVhbGl0eTogZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMsIGF0dHJpYnV0ZSwgYXR0cmlidXRlcywgZ2xvYmFsT3B0aW9ucykge1xuICAgICAgaWYgKCF2LmlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodi5pc1N0cmluZyhvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0ge2F0dHJpYnV0ZTogb3B0aW9uc307XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gdi5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICB0aGlzLm1lc3NhZ2UgfHxcbiAgICAgICAgXCJpcyBub3QgZXF1YWwgdG8gJXthdHRyaWJ1dGV9XCI7XG5cbiAgICAgIGlmICh2LmlzRW1wdHkob3B0aW9ucy5hdHRyaWJ1dGUpIHx8ICF2LmlzU3RyaW5nKG9wdGlvbnMuYXR0cmlidXRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXR0cmlidXRlIG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3RoZXJWYWx1ZSA9IHYuZ2V0RGVlcE9iamVjdFZhbHVlKGF0dHJpYnV0ZXMsIG9wdGlvbnMuYXR0cmlidXRlKVxuICAgICAgICAsIGNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3IgfHwgZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgICAgICAgcmV0dXJuIHYxID09PSB2MjtcbiAgICAgICAgfVxuICAgICAgICAsIHByZXR0aWZ5ID0gb3B0aW9ucy5wcmV0dGlmeSB8fFxuICAgICAgICAgIChnbG9iYWxPcHRpb25zICYmIGdsb2JhbE9wdGlvbnMucHJldHRpZnkpIHx8XG4gICAgICAgICAgdi5wcmV0dGlmeTtcblxuICAgICAgaWYgKCFjb21wYXJhdG9yKHZhbHVlLCBvdGhlclZhbHVlLCBvcHRpb25zLCBhdHRyaWJ1dGUsIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHJldHVybiB2LmZvcm1hdChtZXNzYWdlLCB7YXR0cmlidXRlOiBwcmV0dGlmeShvcHRpb25zLmF0dHJpYnV0ZSl9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEEgVVJMIHZhbGlkYXRvciB0aGF0IGlzIHVzZWQgdG8gdmFsaWRhdGUgVVJMcyB3aXRoIHRoZSBhYmlsaXR5IHRvXG4gICAgLy8gcmVzdHJpY3Qgc2NoZW1lcyBhbmQgc29tZSBkb21haW5zLlxuICAgIHVybDogZnVuY3Rpb24odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdi5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IHYuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCB0aGlzLm1lc3NhZ2UgfHwgXCJpcyBub3QgYSB2YWxpZCB1cmxcIlxuICAgICAgICAsIHNjaGVtZXMgPSBvcHRpb25zLnNjaGVtZXMgfHwgdGhpcy5zY2hlbWVzIHx8IFsnaHR0cCcsICdodHRwcyddXG4gICAgICAgICwgYWxsb3dMb2NhbCA9IG9wdGlvbnMuYWxsb3dMb2NhbCB8fCB0aGlzLmFsbG93TG9jYWwgfHwgZmFsc2VcbiAgICAgICAgLCBhbGxvd0RhdGFVcmwgPSBvcHRpb25zLmFsbG93RGF0YVVybCB8fCB0aGlzLmFsbG93RGF0YVVybCB8fCBmYWxzZTtcbiAgICAgIGlmICghdi5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG4gICAgICB2YXIgcmVnZXggPVxuICAgICAgICBcIl5cIiArXG4gICAgICAgIC8vIHByb3RvY29sIGlkZW50aWZpZXJcbiAgICAgICAgXCIoPzooPzpcIiArIHNjaGVtZXMuam9pbihcInxcIikgKyBcIik6Ly8pXCIgK1xuICAgICAgICAvLyB1c2VyOnBhc3MgYXV0aGVudGljYXRpb25cbiAgICAgICAgXCIoPzpcXFxcUysoPzo6XFxcXFMqKT9AKT9cIiArXG4gICAgICAgIFwiKD86XCI7XG5cbiAgICAgIHZhciB0bGQgPSBcIig/OlxcXFwuKD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmZdezIsfSkpXCI7XG5cbiAgICAgIGlmIChhbGxvd0xvY2FsKSB7XG4gICAgICAgIHRsZCArPSBcIj9cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZ2V4ICs9XG4gICAgICAgICAgLy8gSVAgYWRkcmVzcyBleGNsdXNpb25cbiAgICAgICAgICAvLyBwcml2YXRlICYgbG9jYWwgbmV0d29ya3NcbiAgICAgICAgICBcIig/ISg/OjEwfDEyNykoPzpcXFxcLlxcXFxkezEsM30pezN9KVwiICtcbiAgICAgICAgICBcIig/ISg/OjE2OVxcXFwuMjU0fDE5MlxcXFwuMTY4KSg/OlxcXFwuXFxcXGR7MSwzfSl7Mn0pXCIgK1xuICAgICAgICAgIFwiKD8hMTcyXFxcXC4oPzoxWzYtOV18MlxcXFxkfDNbMC0xXSkoPzpcXFxcLlxcXFxkezEsM30pezJ9KVwiO1xuICAgICAgfVxuXG4gICAgICByZWdleCArPVxuICAgICAgICAgIC8vIElQIGFkZHJlc3MgZG90dGVkIG5vdGF0aW9uIG9jdGV0c1xuICAgICAgICAgIC8vIGV4Y2x1ZGVzIGxvb3BiYWNrIG5ldHdvcmsgMC4wLjAuMFxuICAgICAgICAgIC8vIGV4Y2x1ZGVzIHJlc2VydmVkIHNwYWNlID49IDIyNC4wLjAuMFxuICAgICAgICAgIC8vIGV4Y2x1ZGVzIG5ldHdvcmsgJiBicm9hY2FzdCBhZGRyZXNzZXNcbiAgICAgICAgICAvLyAoZmlyc3QgJiBsYXN0IElQIGFkZHJlc3Mgb2YgZWFjaCBjbGFzcylcbiAgICAgICAgICBcIig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMDFdXFxcXGR8MjJbMC0zXSlcIiArXG4gICAgICAgICAgXCIoPzpcXFxcLig/OjE/XFxcXGR7MSwyfXwyWzAtNF1cXFxcZHwyNVswLTVdKSl7Mn1cIiArXG4gICAgICAgICAgXCIoPzpcXFxcLig/OlsxLTldXFxcXGQ/fDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNF0pKVwiICtcbiAgICAgICAgXCJ8XCIgK1xuICAgICAgICAgIC8vIGhvc3QgbmFtZVxuICAgICAgICAgIFwiKD86KD86W2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldLSopKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSspXCIgK1xuICAgICAgICAgIC8vIGRvbWFpbiBuYW1lXG4gICAgICAgICAgXCIoPzpcXFxcLig/OlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XS0qKSpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV0rKSpcIiArXG4gICAgICAgICAgdGxkICtcbiAgICAgICAgXCIpXCIgK1xuICAgICAgICAvLyBwb3J0IG51bWJlclxuICAgICAgICBcIig/OjpcXFxcZHsyLDV9KT9cIiArXG4gICAgICAgIC8vIHJlc291cmNlIHBhdGhcbiAgICAgICAgXCIoPzpbLz8jXVxcXFxTKik/XCIgK1xuICAgICAgXCIkXCI7XG5cbiAgICAgIGlmIChhbGxvd0RhdGFVcmwpIHtcbiAgICAgICAgLy8gUkZDIDIzOTdcbiAgICAgICAgdmFyIG1lZGlhVHlwZSA9IFwiXFxcXHcrXFxcXC9bLSsuXFxcXHddKyg/OjtbXFxcXHc9XSspKlwiO1xuICAgICAgICB2YXIgdXJsY2hhciA9IFwiW0EtWmEtejAtOS1fLiF+XFxcXConKCk7XFxcXC8/OkAmPSskLCVdKlwiO1xuICAgICAgICB2YXIgZGF0YXVybCA9IFwiZGF0YTooPzpcIittZWRpYVR5cGUrXCIpPyg/OjtiYXNlNjQpPyxcIit1cmxjaGFyO1xuICAgICAgICByZWdleCA9IFwiKD86XCIrcmVnZXgrXCIpfCg/Ol5cIitkYXRhdXJsK1wiJClcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIFBBVFRFUk4gPSBuZXcgUmVnRXhwKHJlZ2V4LCAnaScpO1xuICAgICAgaWYgKCFQQVRURVJOLmV4ZWModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogdi5leHRlbmQoZnVuY3Rpb24odmFsdWUsIG9yaWdpbmFsT3B0aW9ucywgYXR0cmlidXRlLCBhdHRyaWJ1dGVzLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBpZiAodi5pc1N0cmluZyhvcmlnaW5hbE9wdGlvbnMpKSB7XG4gICAgICAgIG9yaWdpbmFsT3B0aW9ucyA9IHt0eXBlOiBvcmlnaW5hbE9wdGlvbnN9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvcHRpb25zID0gdi5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3JpZ2luYWxPcHRpb25zKTtcblxuICAgICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICBpZiAoIXYuaXNEZWZpbmVkKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHR5cGUgd2FzIHNwZWNpZmllZFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoZWNrO1xuICAgICAgaWYgKHYuaXNGdW5jdGlvbih0eXBlKSkge1xuICAgICAgICBjaGVjayA9IHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICB9XG5cbiAgICAgIGlmICghdi5pc0Z1bmN0aW9uKGNoZWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YWxpZGF0ZS52YWxpZGF0b3JzLnR5cGUudHlwZXMuXCIgKyB0eXBlICsgXCIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjaGVjayh2YWx1ZSwgb3B0aW9ucywgYXR0cmlidXRlLCBhdHRyaWJ1dGVzLCBnbG9iYWxPcHRpb25zKSkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG9yaWdpbmFsT3B0aW9ucy5tZXNzYWdlIHx8XG4gICAgICAgICAgdGhpcy5tZXNzYWdlc1t0eXBlXSB8fFxuICAgICAgICAgIHRoaXMubWVzc2FnZSB8fFxuICAgICAgICAgIG9wdGlvbnMubWVzc2FnZSB8fFxuICAgICAgICAgICh2LmlzRnVuY3Rpb24odHlwZSkgPyBcIm11c3QgYmUgb2YgdGhlIGNvcnJlY3QgdHlwZVwiIDogXCJtdXN0IGJlIG9mIHR5cGUgJXt0eXBlfVwiKTtcblxuICAgICAgICBpZiAodi5pc0Z1bmN0aW9uKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UodmFsdWUsIG9yaWdpbmFsT3B0aW9ucywgYXR0cmlidXRlLCBhdHRyaWJ1dGVzLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2LmZvcm1hdChtZXNzYWdlLCB7YXR0cmlidXRlOiB2LnByZXR0aWZ5KGF0dHJpYnV0ZSksIHR5cGU6IHR5cGV9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB0eXBlczoge1xuICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHYuaXNPYmplY3QodmFsdWUpICYmICF2LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhcnJheTogdi5pc0FycmF5LFxuICAgICAgICBpbnRlZ2VyOiB2LmlzSW50ZWdlcixcbiAgICAgICAgbnVtYmVyOiB2LmlzTnVtYmVyLFxuICAgICAgICBzdHJpbmc6IHYuaXNTdHJpbmcsXG4gICAgICAgIGRhdGU6IHYuaXNEYXRlLFxuICAgICAgICBib29sZWFuOiB2LmlzQm9vbGVhblxuICAgICAgfSxcbiAgICAgIG1lc3NhZ2VzOiB7fVxuICAgIH0pXG4gIH07XG5cbiAgdmFsaWRhdGUuZm9ybWF0dGVycyA9IHtcbiAgICBkZXRhaWxlZDogZnVuY3Rpb24oZXJyb3JzKSB7cmV0dXJuIGVycm9yczt9LFxuICAgIGZsYXQ6IHYuZmxhdHRlbkVycm9yc1RvQXJyYXksXG4gICAgZ3JvdXBlZDogZnVuY3Rpb24oZXJyb3JzKSB7XG4gICAgICB2YXIgYXR0cjtcblxuICAgICAgZXJyb3JzID0gdi5ncm91cEVycm9yc0J5QXR0cmlidXRlKGVycm9ycyk7XG4gICAgICBmb3IgKGF0dHIgaW4gZXJyb3JzKSB7XG4gICAgICAgIGVycm9yc1thdHRyXSA9IHYuZmxhdHRlbkVycm9yc1RvQXJyYXkoZXJyb3JzW2F0dHJdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfSxcbiAgICBjb25zdHJhaW50OiBmdW5jdGlvbihlcnJvcnMpIHtcbiAgICAgIHZhciBhdHRyO1xuICAgICAgZXJyb3JzID0gdi5ncm91cEVycm9yc0J5QXR0cmlidXRlKGVycm9ycyk7XG4gICAgICBmb3IgKGF0dHIgaW4gZXJyb3JzKSB7XG4gICAgICAgIGVycm9yc1thdHRyXSA9IGVycm9yc1thdHRyXS5tYXAoZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWxpZGF0b3I7XG4gICAgICAgIH0pLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlLmV4cG9zZU1vZHVsZSh2YWxpZGF0ZSwgdGhpcywgZXhwb3J0cywgbW9kdWxlLCBkZWZpbmUpO1xufSkuY2FsbCh0aGlzLFxuICAgICAgICB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBleHBvcnRzIDogbnVsbCxcbiAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBtb2R1bGUgOiBudWxsLFxuICAgICAgICB0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGRlZmluZSA6IG51bGwpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/validate.js/validate.js\n");

/***/ }),

/***/ "./src/script.js":
/*!***********************!*\
  !*** ./src/script.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _form_validation_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @form-validation/core */ \"../node_modules/@form-validation/core/lib/index.js\");\n/* harmony import */ var _form_validation_plugin_pure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @form-validation/plugin-pure */ \"../node_modules/@form-validation/plugin-pure/lib/index.js\");\n/* harmony import */ var validate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! validate.js */ \"../node_modules/validate.js/validate.js\");\n/* harmony import */ var validate_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(validate_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2NyaXB0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBQ0c7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0LmpzPzY4YjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEZvcm1WYWxpZGF0aW9uIGZyb20gJ0Bmb3JtLXZhbGlkYXRpb24vY29yZSc7XG5pbXBvcnQgUGx1Z2luUHVyZSBmcm9tICdAZm9ybS12YWxpZGF0aW9uL3BsdWdpbi1wdXJlJztcbmltcG9ydCB2YWxpZGF0ZSBmcm9tICd2YWxpZGF0ZS5qcyc7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/script.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/script.js");
/******/ 	
/******/ })()
;